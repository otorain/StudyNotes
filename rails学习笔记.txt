#encoding: UTF-8
----------------------------------------------------------------------
一.rails 初步熟悉

：：安装初步：：：：：
#创建项目 
rails new 项目名

#创建的各种文件夹用途
Gemfile #設定Rails應用程式會使用哪些Gems套件
README	#專案說明：你可以用來告訴其他人你的應用程式是做什麼用的，如何使用等等。
Rakefile#用來載入可以被命令列執行的一些Rake任務
app/	#放Controllers、Models和Views檔案，接下來的內容主要都在這個目錄。
app/helpers #对应views的小工具，名陈通常按controller，但每一个helper都可以在任意一个view里面使用
app/assets #放js,image，css等静态文件
config/	#應用程式設定檔、路由規則、資料庫設定等等
config.ru#Rack伺服器設定檔
db/	#資料庫的結構綱要
doc/	#用來放你的文件
lib/	#放一些自定的Module和類別檔案
lib/tasks #放一些定义任务的脚本，通常和rake相关
log/	#應用程式的Log記錄檔
public/	#唯一可以在網路上看到的目錄，這是你的圖檔、JavaScript、CSS和其他靜態檔案擺放的地方
script/	#放rails這個指令和放其他的script指令
test/	#單元測試、fixtures及整合測試等程式
tmp/	#暫時性的檔案
vendor/	#用來放第三方程式碼外掛的目錄
config/initializers #这个文件夹下面的rb文件可以在启动时执行

#bundle初步
bundle或者bundle install 
检查gemfile里面的gem依存问题，每次这个文件夹更改，就要bundle一次
bundle package #可以把install后的gem打包到本地的 项目/vendor/cache中,或者.package里面
bundle install --local #可以从/vendor/cache中的本地包安装
bundle check #可以查看还缺少哪些gem,然后可以gem install到系统
bundle show gem_name #可以查看这个gem所在的目录
bundle open gem_name #可以打开这个gem的目录

#修改Gemfile
“rails” :path => "~/some/local/path" #可以这样指定已安装的gem
"sqlite3-ruby" :require => "sqlite3" #指定在程序中require的名称
"rails" :git => "xxx",branch => "xxx" #使用git作为gem地址
（有时可以用gem-fast,先用gem装好gem,然后把path指定去系统的rubycache这样会更快）

#获取系统路径#
Rails.root 可以获取当前rails的系统绝对路径

#使用mysql
rails3 默认使用sqlite3，要换成mysql
(1) 修改Gemfile文件，把sqlite3换成mysql2
(2) 修改 项目/config/database.yml文件,development test production都改下，下面列出其中一个
development:
  adapter: mysql2
  encoding: utf8
  database: demo_development
  host: localhost
  username: "root"
  password: "xxxxx"

#ubuntu下遇到sqlite问题
sudo apt-get install libsqlite3-dev
sudo apt-get install sqlite3

#ubuntu下遇到javascript问题
Gemfile加上一行
gem 'therubyracer'

#安装完ruby后某些库没安装，会引起zlib缺失readline缺失等问题#
可以进入 ruby源文件/ext文件夹有各种库，例如readline
先编译装好readline的开发安装包（zlib等同理），读一下包内的README文件就可以知道依赖包是什么,然后下源码包或者apt-get,通常装完后系统会有个zlib.h或者readline.h等的东西
cd readline
ruby extconf.rb
make && makeinstall

#启动webrick服务器p
在rails项目文件夹下,输入命令启动，默认端口是3000
rails server 

#### Hello World ##########
(1)命令行 ：rails generate controller welcome
(2)修改 项目/config/routes.rb
Demo::Application.routes.draw do
    get "hello/say_hello" => "hello#say" #加入这行   
end
(3)修改 项目/app/controller/hello_controller.rb
加入 say方法
(4)修改  项目/app/views/hello/say.html.erb
加入 <h1>hello world!</h1>
(5)浏览器访问 http://localhost:3000/hello/say_hello

#设定首页# （例如把helloworld设置为localhost:3000首页）
先删除public下的index.html文件，修改confit/routes.rb，加入：
root :to => "hello#say_hello"

#link to初步，在erb模板里
<%= link_to "fuck",root_path %>
相当于 <a href="http://localhost:3000">fuck</a>

#helper初步#
像上述link_to 后面的root_path就是一个helper应用，这通常是一个方法，可以有弹性地指定链接的地址，不用把地址写死
#数据库初步#
修改好 config/database.yml后：
bundle exec rake db:create #rails会自动帮你生成好表

在controller里面，用 helper_method :xxxx 定义好的方法在view里面也能使用的helper

#yml问题#
YAML格式嚴格要求縮排(建議為兩個空白)，且冒號後面必須有一個空隔。一般我們會預期YAML的值解析出來是字串，因此碰上值是數字或多行內容時，建議加上引號避免字串解析錯誤。例如 password: "123456"。如果沒有加上引號，這串數字會被解析成Fixnum物件而不是字串String。

#scaffold初步#
scaffold是一个代码生成器，通常用手动生成可控性更好，也可以修改scaffold的模板令我们有更高的开发效率
（1）运行:
rails g scaffold person name:string bio:text birthday:date #然后会生成一大堆东西，注意controller里person都变成复数people
（2）运行：
bundle exec rake db:migrate #执行生成数据库表操作
（3）访问：
http://localhost:3000/people

#rails console#
输入rais console或者 rails c可以进入rails命令行模式

#migrate初步#
migrate是管理数据库方面的各种设定，配置的脚本放在 db/migrate/ 下面，脚本可跨数据库执行
举例在events表添加一列：
rails g migration add_status_to_eventsp

#执行完上句会生成一个类似的文件，修改之： db/migrate/20110519123819_add_status_to_events.rb
class AddStatusToEvents < ActiveRecord::Migration
  def change
    add_column :events, :status, :string #在events表加入一个status的字段，string类型
  end
end

3.1之前的写法是不写在change方法里，而是写在self.up或者self.down里（创建或者移除）

#validation初步#
validation用于各种验证，例如：
validates_presence_of :name #加入event model里，说明：name 不能为空

#Layout模板布局初步#
layout用于所有.erb文件的头部或者尾部，默认的layout在 app/views/layout/application.html.erb
<%= yield %> 的地方就是会替换成样板的地方
例如修改title: <title><%= @page_title || 'DEMO FUCK?' %></title>  /
然后在controle中的action中加入 @show_title = @event.name
那该页面的title就会变成event.name 或者 'DEMO FUCK?'的值

#before_filter初步(类似spring的切面)
例如上面的show edit update等的action里面都有个@event = Event.find(param[:id]),我们可以把他抽取出来,在controller加入：
  before_filter :find_event, :only => [ :show, :edit, :update, :destroy] #在各种action前先执行find_event方法
protected 
def find_event
  @event = Event.find(param[:id])
end
#切面方法使用protected或者private防止方法被认为是action

#分页初步#
（1）Gemfile中加一个gem gem "kaminari"
（2）controller里取变成: @events = Event.page(params[:page]).per(5) #5个一页
（3）view里 <%paginate @events%>

#rails统计行数#
bundle exec rake stats

#关于调试#
#日志
（1）可以在views里面加<% debug(@event)%>打印出各种属性
（2）另一种方法是使用log,会记录在log/development.log,可常用 tail -f去查看
在Rails環境中，你可以直接使用logger或是Rails.logger來拿到這個Logger对象，它有幾個方法可以呼叫：
  logger.debug 除錯用的訊息，Production環境會忽略
  logger.info 值得記錄的一般訊息
  logger.warn 值得記錄的警告訊息
  logger.error 錯誤訊息，但還不到網站無法執行的地步
  logger.fatal 嚴重錯誤到網站無法執行的訊息
例如想看@event的值：
  Rails.logger.debug("event: #{@event.inspect}")

  写入log:
Rails.logger.info "something"
3)清除log
rake log:clear

#一个简单的rake任务#
脚本写在 lib/tasks里面，要以.rake后缀名

namespace :db do
    desc "Print migrated versions" #描述下面的任务，rake -T可以看到描述
    task :schema_migrations => :environment do
	puts ActiceRecord::Base.connection.select_values (
	    'select version from schema_migrations order by version'
	)
    end
end

执行时可以指定哪个环境
rake RAILS_ENV=production db:schema_migrations
----------------------------------------------------------------------
二. REST
#Rest里一种URL代表一种资源(resource),对应四种post/put/get/delete方式，用上面events例子一一对应：
events/create #post
events/update #put
events/show #get
events/destroy #delete


#ruby中建立rest非常简单,在routes.rb里加入 resorces :events,就会自动对应到7个actions（rails规定，需要记下来）：
get    '/events'          => "events#index",   :as => "events"
post   '/events'          => "events#create",  :as => "events"
get    '/events/:id'      => "events#show",    :as => "event"
put    '/events/:id'      => "events#update",  :as => "event"
delete '/events/:id'      => "events#destroy", :as => "event"
get    '/events/new'      => "events#new",     :as => "new_event"
get    '/events/:id/edit' => "events#edit",    :as => "edit_event"
#以http的动词去决定action行为，例如url /events，get行为是取events，post行为是create events
#上述的各种对应地址，在link_to里会使用各种events_path这个方法，有些要传入参数，例如edit delete等，有些不用
#圣经里面一个关于记忆helper和url和行为各种搭配的方法：
注意到這七個Action方法的名字，Rails是定好的，無法修改。這一套慣例建議你背起來，你可以這樣記憶：
  show、new、edit、update、destroy是單數，對單一元素操作
  index、create是複數，對群集操作
  event_path(@event)需要參數，根據HTTP動詞決定show、update、destroy
  events_path毋需參數，根據HTTP動詞決定index、create
因此，最後我們不寫：
  link_to event.name, :controller => 'events', :action => :show , :id => event.id
而改寫成：
  link_to event.name, event_path(event)
而且只需記得resources就可以寫出URL Helper。
  [custom route]_event[s]_path( event ), :method => GET | POST | PUT | DELETE
#_path結尾是相對網址，而_url結尾則會加上完整Domain網址。


####实战修改一个restful版本的CRUD#####
（1）在routes.rb 里加入 resources :events #加在越上的地方优先级越高
（2）編輯app/views/events/index.html.erb，修改各個link_to的路徑：
<% @events.each do |event| %>
  <li>
    <%= link_to event.name, event_path(event) %>
    <%= link_to 'edit', edit_event_path(event) %>
    <%= button_to 'delete', event_path(event), :method => :delete %>
  </li>
<% end %>
</ul> 
<%= link_to 'new event', new_event_path %>
#注意delete里面的 :method => :delete,因为浏览器只有get和post的方法，method delete用于方便rails识别是delete操作，另link_to还有浏览器如果没打开javascript则会失效的问题，可以改成用button_to, 个人感想：这些自动化东西包装得太厉害了，查看网页源码<a>标签有一大堆属性

（3）編輯app/views/events/show.html.erb，修改link_to的路徑：
<%= @event.name %>
<%= simple_format(@event.description) %> 
<p><%= link_to 'back to index', events_path %></p>

（4）修改app/views/events/new.html.erb的表單送出位置如下：
<%= form_for @event, :url => events_path do |f| %>
#在本例中，你也可以完全省略:url參數，Rails可以根據@event推算出路由。

（5）修改app/views/events/edit.html.erb的表單送出位置如下：
<%= form_for @event, :url => event_path(@event), :method => :put do |f| %>
#:url和:method也可以省略，Rails會根據@event是新建的還是修改來推算出要不要使用PUT。

（6）修改app/controllers/events_controller.rb，將create Action和destroy Action裡的redirect_to改成
  redirect_to events_url
而update Action中的redirect_to改成
  redirect_to event_url(@event)
（7）一旦完成RESTful之後，我們在上一章一開始設定的典型路由就用不到了，編輯config/routes.rb將以下程式註解掉：
# This is a legacy wild controller route that's not recommended for RESTful applications.
# Note: This route will make all actions in every controller accessible via GET requests.
# match ':controller(/:action(/:id(.:format)))'
前兩行的註解告訴你，這種典型路由已經不被新的RESTful風格所推薦使用。特別是它會讓所有Actions都可以透過GET讀取到，例如接收表單的create Action最好只允許POST請求，但是打開典型路由就會讓GET請求也可以作用 ☹
##############################################################

#！！！##使用respond_to ##
respond_to可以让我们返回各种格式，xml/json/atom等

（1）修改app/controllers/events_controller.rb的index Action加上XML、JSON和Atom的支援，其中to_xml和to_json是ActiveRecord內建的方法：
def index
  @events = Event.page(params[:page]).per(5)  
  respond_to do |format|
    format.html # index.html.erb
    format.xml { render :xml => @events.to_xml }
    format.json { render :json => @events.to_json }
    format.atom { @feed_title = "My event list" } # index.atom.builder
  end
end
#json处可修改成 {render :json => {id:@event.id,name:@event.name}}去手动指定json的值

（2）如果要在页面生成各种格式的链接，可以在helper的path里面加 :format =>:json 之类的参数，例:
    <%= link_to " (XML)", event_path(event, :format => :xml) %>
    <%= link_to " (JSON)", event_path(event, :format => :json) %>

----------------------------------------------------------------------
三, 环境配置和bundler
#多重环境#
rails有development test prodution三种环境，分为开发 测试 上线产品三种
区别设置在database.yml和config/environments下的三个设置文件，还有设置不同层级的 Log Session Email
也可以设置自己的模式，如 config/environments/jas.rb

#rails指令#
指令可以简写，例如rails generate 可以简写成为rails g
(1)generate 生成mvc中的mv
rails g model person name:string age:integer birthday:data

(2)console 进入rails命令行
rails c production #默认是进入develoment环境，可以在进入时指定环境
rails c --sandbox #沙箱，任何修改都会在推出的时候还原(transaction)
exit 或者 ctrl+z #退出console

(3)server 开启一个web服务器
rails s -p 4000 -e production #指定访问端口4000,环境是production

(4)new  建立一個新 Rails 專案
rails new my_app #將會建立一個叫做 MyApp 的 Rails 專案在 ./my_app 目錄下。它有一些參數可以使用
--database=DATABASE #可以改變 config/database.yml 的預設值
--skip-prototype #可以不產生 prototype.js 檔案
--skip-git #可以忽略為了 Git 版本控制而產生的 .gitignore 和 .gitkeep 檔案

(5)其他指令
dbconsole #開起一個資料庫主控台 (可簡寫為 rails db)，讓你直接輸入 SQL 指令。
destroy #刪除 “generate” 所產生的檔案
benchmarker #產生 benchmark 資訊
profiler #產生 profiler 資訊
plugin #安裝 Plugin
runner #在 Rails 環境中執行一段程式，例如 rails runner “puts Person.count”

#config/application.rb（rails3的服务器设定文件）#
(1)rails默认自动会读 models,controller,views目录下面的文件，但有时太多models的话可以使用子目录，但是无需修改文件，只要在application.rb里面把文件夹加入autoload_paths就行，例如要添加一个models/foobar的子目录:
config.autoload_paths += %W( #{config.root}/app/lib #{config.root}/app/models/foobar)

(2)rails载入plugin是按照字母顺序，可以在以下这句手动设定他的顺序，把他们排在:all前面
config.plugins = [ :exception_notification, :ssl_requirement, :all ]

(3)设置ActiveRecord(orm)的观察者模式，例如数据库有变动就会通知到XX
# Activate observers that should always be running.
config.active_record.observers = :cacher, :garbage_collector, :forum_observer

(4)设置默认时区
config.time_zone = 'Taipei' #把时区设置成台北

(5)设定i18n
config.i18n.default_locale = :zh_tw

(6)log不记录password
config.filter_parameters << :password

(7)设置generator
config.generator do |g|
    g.assets false
    g.orm :active_record
    g.template_engine :haml
end

#config/initialize/下面的各种设定#
这个目录下面的.rb文件会在rails启动时自动运行
(1)backtrace silencers 
可以定义移除exception信息，方便追踪主要逻辑错误

(2)inflections
rails非常注重单数复数形式，这个文件记录了各种转换规则，例如person会变成people,可以里面自定义自己的规则
可进入rails c 查看单复数转换
  $ rails c
  $ Loading development environment (Rails 3.0.5)
  $ > "Business".singularize  => "Busines" # 轉單數 单数
  $ > "moose".pluralize => "mooses"  # 轉複數

有时修改了不符合rails复数的表名会有问题，找不到表，可以修改
config/infections.rb
ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.irregular 'campus', 'campuses'
end

(3)mime_types 定义各种request数据文件类型

(4)secret_token 定义cookie的一些加密信息

(5)sesssion_store rails默认把session放在客户端中，也可以把他定义到数据库

#config/environments/develoments#
(1)config.cache_classes = false
这是每次修改了脚本之后都可以刷新马上获得新结果的奥秘之处
false时ruby使用的是load，就是每次都重新读一次
true时ruby使用的是require, 就是只有第一次读的时候会读入这个依赖文件

(2)config.whiny_nils = true
对nil呼叫方法時，會出現 NoMethodError。whiny_nils = true 會提示你更多訊息來除錯。這個值在 production 預設是 false。

(3)config.action_mailer.raise_delivery_errors = false
如果寄信失敗，是否要丟出例外。建議可以改成 true。

#production的设定和develoments类似#
(1)# config.force_ssl = true
是否强制所有的链接都使用ssl

(2)# config.cache_store = :mem_cache_store
設定不同的快取儲存庫，預設是 :memory_store，也就是每個 Rails process 各自用記憶體存放

(3)# config.action_controller.asset_host = "http://assets.example.com"
預設的靜態檔案位置是目前主機的 public 目錄，你可以透過修改 asset_host 變更位置。主要用于集群使用

#database.yml#
mysql的设法
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  username: root
  password:
test:
  xxxx

###########################
#bundler与Gemfile#
所有require的gem都一定要写到Gemfile里头,rails不写的话require不到

(1)让特定环境才载入特定的gem
 group :development, :test do
     gem "rspec", "~> 2.0"
     gem "rspec-rails", "~> 2.0"
     gem "omniauth-douban", :path => '~/project/douban' #这样可以使用开发中的gem
 end

(2)打包gems
bundle package #之后会把所有gem都打包到vendor/cache里面

#命名惯例#
Rails.root 可以获取当前rails的系统绝对路径
(1)文件名用小写，下划线分开 例如要读入一个 class FootballCoach,rails会自动到auto_paths下面找football_coach.rb

(2)如果是有嵌套的類別或模組，例如 Admin::OrderItem，則會多一層目錄，它會自動載入 admin/order_item.rb 的檔案，也就是 require “admin/order_item”。

一般只要按惯例去写，就不用使用require

#Model 命名#
類別名稱使用大寫、單數，沒有底線。而檔名使用小寫、單數，用底線。資料庫表格名稱用小寫且為複數。例如：
  資料庫表格 line_items
  檔名 app/models/line_item.rb
  類別名稱 LineItem

#Controller 命名#
如果使用典型路徑：
  網址 http://../store/list
  檔名 app/controllers/store_controller.rb
  類別名稱 StoreController
  方法名稱 list
  Layout 檔案 app/views/layouts/store.html.erb
  Template 檔案 app/views/store/list.html.erb

如果使用 RESTful 路徑，則 Controller 名稱必為複數，方法名稱依照 RESTful 的慣例有七個 index, show, new, edit, update, create, destroy。

#View 命名#
例如一個叫做 People 的 controller，其中的 index action：
  檔名 app/views/people/index.html.erb (或 .builder or .rjs)
  Helper 名稱 module PeopleHelper
  檔名 app/helpers/people_helper.rb

#############################
#rails组件概览#
Action Pack #Action Pack 是個包含 Action Controller、Action View 和 Action Dispatch 的 gem。也就是 “MVC” 中的 “VC” 部分。
Action Controller #分离请求与结果,还有session和redirect功能
Action Dispatch #处理路由
Action View #表现层
Action Mailer #邮件
Active Model #数据库抽象层，定义了一堆接口，可以把Active Record换成其他orm框架
Active Record #orm框架
Active Resource #可以把web应用本地化，实用性不大
Active Support #放了rails的标准函数库，开发时也可以调用
Railties #核心库

----------------------------------------------------------------------
四,Routing 路由
不同于php，url实际是和文件夹结构结合，rails把路由功能直接嵌入到框架，可以用任意url定位到任意的action

#路由的作用#
(1) 辨識HTTP Request的URL網址，然後對應到設定的Controller Action。

(2)處理網址內的參數字串，例如：/users/show/123送到Users controller的show action時，會將params[:id] 設定為 123

(3)辨識link_to和redirect_to的參數產生URL字串，例如
  link_to 'hola!', { :controller=> 'welcome', :action => 'say' } #生成<a href="/welcome/say">hola!</a>

#各种路由设定方式#
修改routes.rb，内里规则也是越上面越优先
(1)典型路由，rails3 之前的方式（之前上面一个例子使用的）,这种方式
match '/:controller(/:action(/:id))(.format)' #.format对应.json .xml等

(2)一般路由
  match 'meetings/:id', :to => 'events#show'
這裡的events#show表示指向events controller的show action。通常會簡寫成：
  match 'meetings/:id' => 'events#show'

(3)命名路由 用于产生helper
match '/meetings' => 'events#index', :as => "meetings" #/meeting 对应events的index action :as后面是会指定一个meetings_path和一个meetings_url的helper,path和url的区别是前者是相对路径，后者是绝对路径

(4)设定首页 
root_to => 'welcome#show'

(5)http动词指定,通过 :via
match 'piece/shit' => 'piece#shit', :via => "get"
match 'piece/shit' => 'piece#shit', :via => [:get,:post]
或者
get 'piece/shit' => 'piece#shit'

(6)特殊条件限定 :constraints
例如限制 :id 必须是整数
match 'events/show/:id' => 'event#show' :constraints=>{:id=>/\d/}
或者
constraints(id: /\d+\.\d+/) do
    resources :posts
end
resources :posts do
  constraints(post_id: /\d+\.\d+/) do
    resources :comments
  end
end

constraints(ip: /192\.168\.\d+\.\d+/) do
    resources :posts
end

这样去做params条件判断分路由
scope :path => "/weixin", :via => :post do
  root :to => 'weixin#method_a', :constraints => lambda { |request| request.params[:xml][:MsgType] == 'image'  }

  root :to => 'weixin#method_b', :constraints => lambda { |request| request.params[:xml][:MsgType] == 'text' && request.params[:xml][:Content].start_with?('@')  }

  root :to => 'weixin#method_c', :constraints => lambda { |request| request.params[:xml][:MsgType] == 'text'  }
end

还可以自己写一个class去适配
scope :path => "/weixin", :via => :post do
  root :to => 'weixin#method_a', :constraints => Weixin::Router.new(:type => "image")

  root :to => 'weixin#method_b', :constraints => Weixin::Router.new(:type => "text", :content => /^@/)

  root :to => 'weixin#method_c', :constraints => Weixin::Router.new(:type => "text")
end

class DemoWeixin::Router
  def initialize(type="text")
    @message_type = type
  end

  def matches?(request)
    xml_data = request.params[:xml]
    if xml_data and xml_data.is_a?(Hash)
      @message_type == request.params[:xml][:MsgType]
    end
  end
end

(6.1) 还可以redirect
match "/stories" => redirect("/posts")
match "/stories/:name" => redirect("/posts/%{name}")
match "/stories/:name" => redirect {|params| "/posts/#{params[:name].pluralize}" }
match "/stories" => redirect {|p, req| "/posts/#{req.subdomain}" }

(7)Restful 路由
a.复数资源
resource :events

b.单数资源
resource :map #特别之处在于没有了index action，但是controller仍然是复数maps_controller.rb

c.指定资源只允许哪些action
resource :map，:only => [:index, :destroy] 
------
c.层叠资源
resources :projects do
  resources :tasks, :people
end 
#产生的url_helper会这样使用：project_tasks_path(@project)和project_task_path(@project, @task)
使用网址就是 projects/123/people/123,不建议超过两层

如上述例子，url_helper有各种作用
project_tasks_path(@project, @task) #常规是这样产生url
url_for([@project, @task]) #url_for 方式产生url !!! 在controller可以直接用url_for方法产生当前action的url
<%= link_to 'project task', [@project, @task]%> #link_to 也可以这样自动产生url
---------
d.自定义action #!!!#
除了自动生成的7个action,还可以用collection自定义：
resources :products do
  collection do
    get  :sold
    post :on_offer
  end
end
#如此便會有sold_products_path和on_offer_products_path這兩個URL Helper，產生出如products/sold和products/on_offer這樣的網址。

也可以这样自定义,member的作用是可以产生出xxx_resource_path的url
resources :products do
  get :sold, :on => :member
end
#或者
resources :products do
   member do
       get :sold
   end
end
#如此會有sold_product_path(@product)這個URL Helper，產生出如products/123/sold這樣的網址。

-----------
e.namespace方式,namespace解决的是分组问题,下面这个例子是要在app/controllers/下面创建一个admin的文件夹
namespace :admin do
  resources :projects
end
#如此原先的URL Helper就會變成如admin_projects_path這樣的形式。url则是 admin/projects 这种方式,并且controller定义是 Admin::ProjectsController < Admin::ApplicationController

如果你想Admin::ProjectsController 这里的url不使用 admin前缀，可以:
scope :module => "admin"  do #多个resource
    :projects, :posts
end
resource :projects, :module => 'admin' #单个resource

如果你想单独使用ProjectsController (不在Admin::的module内), 但又想要 /admin/projects 的url前缀, 可以
scope '/admin' do #多个
    :projects, :posts
end
resource :projects, :path => '/admin/projects' 
----------------
#rake routes#
使用rake routes，在不清楚有什么路由的时候，这个命令可以把所有路由产生出来

----------------------------------------------------------------------
五,Action Controllor
所有预设生成的Controllor 都继承自ApplicationControllor,而ApplictionControllor 继承自ActionControllor::Base,里面的protect_from_forgery方法啟動了CSRF安全性功能，所有非GET的HTTP request都必須帶有一個Token參數才能存取，Rails會自動在所有表單中幫你插入Token參數，預設的Layout中也有一行<%= csrf_meta_tag %>

取消 cancel csrf检测
protect_from_forgery :except => :index

class FooController < ApplicationController
  protect_from_forgery :except => :index
You can disable csrf protection on controller-by-controller basis:
  skip_before_filter :verify_authenticity_token
It can also be disabled for specific controller actions:
  skip_before_filter :verify_authenticity_token, :except => [:create]

#产生Controller#
rails g controller events #如此便會產生app/controllers/events_controller.rb，依照RESTful設計的慣例，所有的Controller命名都是複數，而檔案名稱依照慣例都是{name}_controller.rb。一個Action就是Controller裡的一個Public方法：

# Controller里的环境方法 #
action_name
cookies
headers
params  #这个最重要
request #下面有这个对象的详细方法
response
session

在Action方法中我們要處理request，基本上會做三件事情: 1. 收集request的資訊，例如使用者傳進來的參數 2. 操作Model來做資料的處理 3. 回傳response結果，這個動作稱作render

#!!!!!!# request各种取值的方法 params[xxx]#
#注:request 这个就是request对象，可以使用以下的方法
request_method
method
delete?, get?, head?, post?, put?
xml_http_request? 或 xhr?
url
protocol, host, port, path 和 query_string
domain
host_with_port
port_string
ssl?
remote_ip?
path_without_extension, path_without_format_and_extension, format_and_extension, relative_path
env
accepts
format
mime_type
content_type
headers
body
content_length

#注意# params這個Hash是ActiveSupport::HashWithIndifferentAccess对象，而不是普通的Hash而已。Ruby的hash[:foo]和hash["foo"]是不一樣的，而在rails中使用ActiveSupport::HashWithIndifferentAccess物件，無論鍵是Symbol或字串，都指涉相同的值，減少麻煩。

# Render(response) #
Render結果
在根據request資訊做好資料處理之後，我們接下來就要回傳結果給用戶。事實上，就算你什麼都不處理，Action方法裡面空空如也，甚至不定義Action，Rails預設也還是會執行render方法。這個render方法會回傳預設的Template，依照Rails慣例就是app/views/{controller_name}/{action_name}。如果找不到樣板檔案的話，會出現Template is missing的錯誤。有以下参数可以用：
a)直接回传结果:
  render :text => "Hello" 直接回傳字串內容，不使用任何樣板。
  render :xml => @event.to_xml 回傳XML格式
  render :json => @event.to_json 回傳JSON格式(再加上:callback就會是JSONP)
  render :nothing => true 空空如也
b)指定Template：
  :template 指定Template
  :action 指定使用該Action的Template(注意到只是使用它的Template，而不會執行該Action內的程式) #这个很奇怪
  :file 指定Template的檔名全名
c)其他参数：
  :status 設定HTTP status，預設是200，也就是正常。其他常用代碼包括401權限不足、404找不到頁面、500伺服器錯誤等。
  :layout 可以指定這個Action的Layout，設成false即關掉Layout

# redirect_to  #
  redirect_to :controller =>'hello', :action => "show", :id => @event
  redirect_to :back 回到上一頁。

# 返回流（回传文件二进制之类） #
send_data(data, options={}) 回傳二進位字串，接受以下參數：
  data 是二進位的字串
  :filename 使用者儲存下來的檔案名稱
  :type 預設是application/octet-stream
  :disposition inline或attachment
  :status 預設是200

send_file(file_location, options={}) 回傳一個檔案，接受以下參數：
  file_location 是檔案路徑和檔名
  :filename 使用者儲存下來的檔案名稱
  :type 預設是application/octet-stream
  :disposition inline或attachment
  :status 預設是200
  :buffer_size stream的暫存空間，預設4096 bytes
  :stream 預設是false，會先將整個檔案先載入記憶體，如果檔案非常大可能造成問題。

# respond_to #
我們在第六章RESTful應用程式中曾經示範過用法，respond_to可以用來回應不同的資料格式。Rails內建支援格式包括有:html, :text, :js, :css, :ics, :csv, :xml, :rss, :atom, :yaml, :json等。如果需要擴充，可以編輯config/initializers/mime_types.rb這個檔案。

如果你想要設定一個else的情況，你可以用:any：

respond_to do |format|
  format.html #自动使用对应的view
  format.xml { render :xml => @event.to_xml }
  format.json {render :json => @event.to_json}
  format.any { render :text => "WTF" }
end

#!!! to_json 的一些参数补充#
  konata.to_json(:only => [ :id, :name ])
  # => {"id": 1, "name": "Konata Izumi"}, 使用only可以指定只生成某几个属性

  konata.to_json(:except => [ :id, :created_at, :age ])
  # => {"name": "Konata Izumi", "awesome": true}, except则是相反

 konata.to_json(:methods => :permalink)
  # => {"id": 1, "name": "Konata Izumi", "age": 16, "created_at": "2006/08/01", "awesome": true, "permalink": "1-konata-izumi"}, 使用:methods可以生成有些虚拟属性获取的值！这个很有效，因为默认只能生成model里有的字段， attr_accessor生成的instance_variables不能，用这个就可以
 
 konata.to_json(:include => :posts)
  # => {"id": 1, "name": "Konata Izumi", "age": 16, "created_at": "2006/08/01", "awesome": true, "posts": [{"id": 1, "author_id": 1, "title": "Welcome to the weblog"}, {"id": 2, author_id: 1, "title": "So I was thinking"}]},  还可以include, include还可以嵌套only, except

#!!to_json nest地狱
respond_with(@posts) do |format|
      format.json { render :json => @posts.to_json(
         :only => [:title, :body, :created_at, :tags, :category],
         :include => [
            :likes => { :only => [:created_at], :include => [:author] },
            :comments => { only => [:created_at, :body], :include => [:author]  },
            :user => { :only => [:first_name, :last_name}, :methods => [:full_name] },
         :methods => [:likes_count, :comments_count])
      } 
end

# Session #
直接操作session这个hash就可以存入取出，如:
session[:siki] = JAS.new

rails默认把Session加密放在Cookie，最大只有4K，而且有安全性问题，除了Cookies session storage，Rails也支援其他方式，你可以修改config/initializers/session_store.rb：
  :active_record_store 用数据库储存
  :mem_cache_store 使用Memcached快取系統來儲存

# Cookie #
直接操作cookies这个hash,各种用法：
  cookies[:user_name] = "david"
  cookies[:login] = { :value => "XJ-122", :expires => 1.hour.from_now }
  cookies.delete :user_name
  cookies[:key] = {
    :value => 'a yummy cookie',
    :expires => 1.year.from_now,
    :domain => 'domain.com'
  }
  cookies.delete(:key, :domain => 'domain.com')
加密：
cookies.signed[:user_preference] = @current_user.preferences
永久:
cookies.permanent[:remember_me] = [current_user.id, current_user.salt]

# Flash讯息 #
flash是一個Hash，其中的鍵你可以自定，常用:notice、:warning或:error

在Action中:
def fuck
  xxx#逻辑
  flash[:notice] = "OK!"
end
那么在view中就可以看到:
<%= flash[:notice] %>

有时想马上让action看到
flash.now[:notice] = "hehe"

# Filters #
可以把controller重复的东东抽取出来；定义在进入action之前，运行中，执行后的特别方法(before_filter,after_filter,around_filter);方法接收的参数可以是block，symbol的方法名(private或者protected),或者对象（会执行这个对象的filter方法）；

a)before_filter,可以使用only或者expect
class EventsControler < ApplicationController
  before_filter :find_event, :only => :show

  def show
  end

  protected
  def find_event
    @event = Event.find(params[:id])
  end  
end

b）around_filter,通常使用方式是直接传入一个filter对象，这个对象的filter方法内的yield的地方就是action执行的地方，例如可以前后包着统计时间来执行action，重要例子：
class BenchmarkFilter
    def self.filter(controller)
     timer = Time.now
     Rails.logger.debug "---#{controller.controller_name} #{controller.action_name}"
     yield # 這裡讓出來執行Action動作
     elapsed_time = Time.now - timer
     Rails.logger.debug "---#{controller.controller_name} #{controller.action_name} finished in %0.3s" % elapsed_time
    end
end

class EventsControler < ApplicationController
    around_filter BenchmarkFilter
end
#注意 filter的顺序是由上到下执行的，可以用prepend_before_filter插入到第一个，或者skip_before_filter 跳过父类的filter


# rescue_from(处理exception) #
    rescue_from ActiveRecord::RecordNotFound, :with => :show_not_found #找不到model的时候用show_not_found的action
    rescue_from ActiveRecord::RecordInvalid, :with => :show_error #

# Basic验证用户名和密码 #
（rails3.x写法）
class PostsController < ApplicationController
    http_basic_authenticate_with :name => "foo", :password => "bar"
end

# controller 里面 debug!!!##########################################################
在action里面某一句写 debugger,如
def create
    debugger
end

启动服务器, rails s --debugger
然后逻辑渠道create时候irb会进入debug模式，可以debug一下request，在写第三方认证时比较有用
#补充, 需要先安装一个ruby-debug的gem, 1.9开始要安装 ruby-debug19，但是可能会有找不到头文件的出错提示,解决方法

1)gem install ruby-debug19 -- --with-ruby-include=$rvm_path/src/ruby-1.9.2-head/ #也有人这样用 gem install ruby-debug19 -- --with-ruby-include="$rvm_path/src/$(rvm tools identifier)/"
#然后在项目的Gemfile加上这一句
2)gem ‘ruby-debug19′, :require => ‘ruby-debug’
3)创建'~/.rdebugrc', 加入
set autolist
set autoeval
set autoreload
set forcestep
4)Specify how you would like Rails to report deprecation notices for your bugger environment, set 
config.active_support.deprecation to :log, :notify or :stderr at config/environments/bugger.rb
5)require 'ruby-debug' in development.rb. Edit source where you want to debug to include : 
#以上5布在1.9.3上面还是有问题， 再来增加下面几步就成功了
去http://rubyforge.org/frs/?group_id=8883 下载:
linecache19-0.5.13.gem 
ruby_core_source-0.1.5.gem 
ruby-debug19-0.11.6.gem 
ruby-debug-base19-0.11.26.gem   

export RVM_SRC='your/path/to/rvm/ruby'
gem install archive-tar-minitar
gem install ruby_core_source-0.1.5.gem -- --with-ruby-include=/$RVM_SRC
gem install linecache19-0.5.13.gem -- --with-ruby-include=/$RVM_SRC
gem install ruby-debug-base19-0.11.26.gem -- --with-ruby-include=/$RVM_SRC
gem install ruby-debug19-0.11.6.gem -- --with-ruby-include=/$RVM_SRC
###########################################################


----------------------------------------------------------------------
六,Action Record
建立Model:
  rails g model category
這個指令會產生幾個檔案
  category.rb
  category_test.rb
  categories.yml
  xxxxxxxx_create_categories.rb

修改xxxxxxxx_create_categories.rb建立表关联：
class CreateCategories < ActiveRecord::Migration
  def change
    create_table :categories do |t|
      t.string :name
      t.integer :position
      t.timestamps
    end
    
    add_column :events, :category_id, :integer #在events表加一列
    add_index :events, :category_id #绑定外键
  end
end

执行 bundle exec rake db:migrate

# 保存 #
四个方法 save save! create create! (无惊叹号返回true或者false,有惊叹号出错抛异常，create是new完就save)
  a = Category.new( :name => 'Ruby', :position => 1 )
  a.save

  b = Category.new( :name => 'Perl', :position => 2 )
  b.save!
        
  Category.create( :name => 'Python', :position => 3 )
  c = Category.create!( :name => 'PHP', :position => 4 )
# 透過 :valiate => false 可以略過驗證 c.save( :validate => false )
# 批量插入!!!!
  Article.create([{content:aa},{content:bb}])

# 查询 #
a)可以用where、limit、select、order查询

b)first/last/all
  c1 = Category.first
  c2 = Category.last
  categories = Category.all # 這會是一個陣列

c)find，直接find id,也可以传如数组一次拿多个，注意如果找不到資料的話，會丟 ActiveRecord::RecordNotFound 例外。如果是 find_by_id 就不會丟出例外，而是回傳 nil。

d)find_by_* 和 find_all_by_*
find_by_* 和 find_all_by_* 是 Rails 的動態方法，可以自由用 and 組合，例如：
  c5 = Category.find_by_name('Ruby')
  c6 = Category.find_by_name_and_position('Ruby', 1)
  c7 = Category.find_all_by_position(2)

e)find_by_sql
如果需要手動撰寫 SQL，可以使用 find_by_sql，例如：
  c8 = Category.find_by_sql("select * from categories")

f)where
c9 = Category.where( :name => 'Ruby', :position => 1 ) #这样没法用or
c10 = Category.where( [ "name = ? or position = ?", 'Ruby', 2] ) #这种最安全推荐用这个
ts = Tag.where("id in (?)",[1,3,5,7,9]) #这样的可以实现 in(?,?,?)的查找
#注意不要用where("[name = #{xxx}]")这种容易被注入攻击
#where是懒加载，需要马上使用可以后面用all first last: Category.where( :name => 'Ruby', :position => 1 ).all

#find_by, find_all_by, where的区别 !!!
find： 根据id查找，返回一个对象
find_by_*： 返回一个对象
find_all_by_*：返回Array
where： 返回ActiveRecord::Relation，操作对象时才执行SQL

g)limit #表示拿多少跳
limit 可以限制筆數
 c = Category.limit(5).all
 c.size # 5

h)order
order 可以設定排序條件
  Category.order("position")
  Category.order("position DESC")
  Category.order("position DESC, name ASC")
如果要消去order條件，可以用reorder：
  Category.order("position").reorder("name") # 改用 name 排序
  Category.order("position").reorder(nil) # 取消所有排序

i)offset(常和limit配合)#表示从哪里开始拿
offset 可以設定忽略前幾筆不取出，通常用於資料分頁：
  c = Category.limit(2)
  c.first.id # 1
  Category.limit(2).offset(3)
  c.first.id # 4

j)select（只取某些字段）
Category.select("id, name")

k)readonly (读出的对象只读不能写）
c = Category.readonly.first

l)group having
#小复习,group by用于聚组函数: select deptno,sum(money) from table group by deptno;
#having用于作为gourp by后的条件筛选 ：select deptno,sum(money) from table group by deptno having money>2000;

m)find_or_create_by#!!!
有时候要插入时先看看数据库有没有，有就更新，没有就create，可以使用这个
# u = User.find_or_create_by_name_and_password_and_email(name:'jas',password:'fuck',email:'gmail') 一个例子

# 串接寫法 #
以上的 where, order , limit, offset, joins, select 等等，都可以自由串接起來組合出最終的 SQL 條件：
  c12 = Category.where( :name => 'Ruby' ).order("id desc").limit(3)

# find_each批次处理#
如果資料量很大，但是又需要全部拿出來處理，可以使用 find_each 批次處理
Category.where("position > 1").find_each do |category|
    category.do_some_thing
end
預設會批次撈 1000 筆，如果需要設定可以加上 :batch_size 參數。

# reload重新载入 #
  p = Category.first
  p.reload


# 删除 #
方法1:
  c1 = Category.find(1)
  c1.destroy
方法2，直接传入ID或者条件:
  Category.delete(2) #没有callback
  Category.delete_all(conditions = nil)
  Category.destroy_all(conditions = nil)  #有callback

# 统计 #
  Category.count
  Category.average(:position)
  Category.maximum(:position)
  Category.sum(:position)
可以用where缩小条件：
  Category.where( :name => "Ruby").count

# 更新update_attributes #
  c13 = Category.first
  c13.update_attributes(attributes) #没有验证
  c13.update_attributes!(attributes) #没有验证
  c13.update_attribute(attribute_name, value)

# 更新update_all #
这语句要在ActiveRecord::Relationship对象使用，亦既是where语句查询出来的集合
如
as = Article.where("catagory_id=?",1)
as.update_all :catagory_id=>0 

update_all(updates, conditions, options)

#!!添加一些update和update_all的例子
#update_all
update_all(updates, conditions = nil, options = {})
updates - A string, array, or hash representing the SET part of an SQL statement.
conditions - A string, array, or hash representing the WHERE part of an SQL statement. See conditions in the intro.
options - Additional options are :limit and :order, see the examples for usage.
例子:
# Update all customers with the given attributes
Customer.update_all :wants_email => true

# Update all books with 'Rails' in their title
Book.update_all "author = 'David'", "title LIKE '%Rails%'"

# Update all avatars migrated more than a week ago
Avatar.update_all ['migrated_at = ?', Time.now.utc], ['migrated_at > ?', 1.week.ago]

# Update all books that match conditions, but limit it to 5 ordered by date
Book.update_all "author = 'David'", "title LIKE '%Rails%'", :order => 'created_at', :limit => 5

# Conditions from the current relation also works
Book.where('title LIKE ?', '%Rails%').update_all(:author => 'David')

# The same idea applies to limit and order
Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(:author => 'David')

##update
update(id, attributes)
id - This should be the id or an array of ids to be updated.
attributes - This should be a hash of attributes or an array of hashes.
例子:
# Updates one record
Person.update(15, :user_name => 'Samuel', :group => 'expert')

# Updates multiple records
people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
Person.update(people.keys, people.values)
-----------------------
# Scope!! #
Scope作用是把某些条件的查询变成一个方法，方便搜索出model：
  class Event < ActiveRecord::Base
    scope :public, where( :is_public => true ) #public的方法就是筛选is_public是true的这个条件
    scope :recent_three_days, where(["created_at > ? ", Time.now - 3.days ]) 
  end

  Event.create( :name => "public event", :is_public => true )
  Event.create( :name => "private event", :is_public => false )
  Event.create( :name => "private event", :is_public => true )

  Event.public
  Event.public.recent_three_days #直接使用，条件也可以叠加

scope也可以带有参数：
  class Event < ActiveRecord::Base
    scope :recent, lambda{ |date| where(["created_at > ? ", date ]) } 
    # 或 scope :recent, Proc.new{ |t| where(["created_at > ? ", t ]) }
  end
  Event.recent( Time.now - 7.days )
不過，筆者會推薦上述這種帶有參數的Scope，改成如下的類別方法，可以比較明確看清楚參數是什麼，特別是你想給預設值的時候：
##记得使用self,因为是定义类方法
  class Event < ActiveRecord::Base
    def self.recent(t=Time.now)
        where(["created_at > ? ", t ])
    end
  end
  Event.recent( Time.now - 7.days )

#注意！！！！用scope取出来的不是一个独立对象，是一个数组，即使只取出一个元素，都要使用[0]去获取独立对象#
 
# unscope #
暂时取消scope
Event.unscoped do
    Event.all
    # SELECT * FROM events
end

#虚拟属性#
有时要参数未必与字段一一对应，例如fullname对应firstname和lastname,就可以在model这样写:
 def full_name
    "#{self.first_name} #{self.last_name}"
 end

 def full_name=(value)
    self.first_name, self.last_name = value.to_s.split(" ", 2)  
 end

#手动sql语句执行!!!#
 c = ActiveRecord::Base.connection
 sql = "update from articles set catagory_id=1"
 c.execute(sql)

 #prepare_statement 安全的做法
st = ActiveRecord::Base.connection.raw_connection.prepare("update table set f1=? where f2=? and f3=?")
st.execute(f1, f2, f3)
st.close

#!!! 修改model id的神技!!
一般来说model的id是不能new的, 但是可以使用Model.instantiate(id:1,name:"a") 这样来new一个id是1的model出来
User.find(1) # name:a
u2 = User.instantiate(id:1, name:"b")
u2.save!
User.find(1) #name:"b"

#判断model是不是已经存入库
u = User.find(:id)
u.new_record? #=> false
u = User.new
u.new_record? #=> true



----------------------------------------------------------------------
六,Migration （屏蔽数据库之间差异，方便发布更改数据库，常用于手动指定数据库）
rails g migration migration_name
就会产生（3.x开始一个change搞掂up和down）：
class MigrationName < ActiveRecord::Migration
  def up #执行时执行
  end

  def down #回滚时执行
  end
end

在up或down方法裡（change），我們有以下方法可以使用：
a)對資料表做修改:
  create_table(name, options) #新增資料表
  drop_table(name) #移除資料表
  rename_table(old_name, new_name) #修改資料表名稱
  change_table #修改資料表欄位
b)個別修改資料表欄位:
  add_column(table, column, type, options) #新增一個欄位
  rename_column(table, old_column_name, new_column_name) #修改欄位名稱
  change_column(table, column, type, options) #修改欄位的型態(type)
  remove_column(table , column) #移除欄位
c)新增、移除索引:
  add_index(table, columns, options) #新增索引
  remove_index(table_name, :column => column_name): Removes the index specified by column_name.
  remove_index(table_name, :name => index_name): Removes the index specified by index_name.
另外，欄位也還有一些參數可以設定：
  :null 是否允許NULL，預設是允許
  :default 預設值
  :limit 用於string、text、integer、binary指定最大值
  create_table :events do |t|
    t.string :name, :null => false, :limit => 60, :default => "N/A"
    t.references :category # 等同於 t.integer :category_id
  end

d)指定数据库引擎是BLACKHOLE
create_table :products, :options => "ENGINE=BLACKHOLE" do |t|
  t.string :name, :null => false
end

e)对于表关联，可以用:
t.references :catagory #这样会生成一个catagory_id,references也可以写成belongs_to



#migrate其他作用#
在migrate还可以直接使用Model, 例如add_column之后,model.update_all;也可以在这里使用sql语句

#Migration 搭配的 Rake 任務#
rake db:create 依照目前的 RAILS_ENV 環境建立資料庫
rake db:create:all 建立所有環境的資料庫
rake db:drop 依照目前的 RAILS_ENV 環境刪除資料庫
rake db:drop:all 刪除所有環境的資料庫
rake db:migrate 執行Migration動作
rake db:rollback STEP=n 回復上N個 Migration 動作
rake db:migrate:up VERSION=20080906120000 執行特定版本的Migration
rake db:migrate:down VERSION=20080906120000 回復特定版本的Migration
rake db:version 目前資料庫的Migration版本
rake db:seed 執行 db/seeds.rb 載入種子資料
rake db:migrate:status !!!可以查看详细migrate信息

#以上任务都可以明确指定env
rake db:migrate RAILS_ENV='production' #text or development

#已存在表名或字段名 与 model属性不符的情况时#
有時候你的資料表名稱和主鍵名稱不一定就是 Rails 預設的慣例，也就是表格名稱不是Model名稱的複數型，主鍵不叫id。這時候我們可以手動設定過，例如以下 Model 預設的資料表和主鍵是legacy_comments和id，但是我們想要改成comment和comment_id：
class LegacyComment < ActeveRecord::Base
    set_table_name :comment
    set_primary_key :comment_id
end

----------------------------------------------------------------------
七,表关系

#一对一 has_one belongs_to#
延續Part1的Event Model範例，假設一個Event擁有一個Location。來新增一個Location Model，其中的event_id就是外部鍵欄位：
  rails g model location name:string event_id:integer
執行bundle exec rake db:migrate
分別編輯app/models/event.rb和app/models/location.rb：
class Event < ActiveRecord::Base
    has_one :location # 單數
    #...
end

class Location < ActiveRecord::Base
    belongs_to :event # 單數
end

1)建立并关联
  e = Event.first
  l = Location.new( :name => 'Hsinchu', :event => e ) # 等同於 l = Location.new( :name => 'Hsinchu', :event_id => e.id )
  l.save
2)从event建立location （xxx.build_yyy）
  e = Event.first
  l = e.build_location( :name => 'Hsinchu' )
3)直接从event建立一个 (xxx.create_yyy)
  e = Event.first
  l = e.create_location( :name => 'Hsinchu' )

# 一对多 #
例如一個Event擁有很多Attendee，來新增Attendee Model：
  rails g model attendee name:string event_id:integer
執行bundle exec rake db:migrate產生attendees資料表。

分別編輯app/models/event.rb和app/models/attendee.rb：
class Event < ActiveRecord::Base
    has_many :attendees # 複數
    #...
end

class Attendee < ActiveRecord::Base
    belongs_to :event # 單數
end

1）范例
  e = Event.first
  a = Attendee.new( :name => 'ihower', :event => e ) # 或 a = Attendee.new( :name => 'ihower', :event_id => e.id )
  a.save
  e.attendees # 這是陣列
  e.attendees.size

2）build和create
  e.attendee.build(xxx) #一对多，所以是model.build，不是e.build_model 
  e.attendee.create(xxx)

3)先建立atendee再放到event
  a = Attendee.create( :name => 'ihower' )
  e.attendees << a

4）根據特定的Event查詢Attendee  
  e.id # 1
  a = e.attendees.find(3)
  attendees = e.attendees.where( :name => 'ihower' )

5）删除
  Event.attendees.destroy_all # 會一筆筆觸發Attendee的destroy回呼
  Event.attendees.delete_all # 不會觸發Attendee的destroy回呼

# 多对多 #
例如一个event有多个group，一个group有多个event，实现的方法是写一个中间表有event_id和group_id
  rails g model group name:string
  rails g model event_groupship event_id:integer group_id:integer
  bundle exec rake db:migrate

分別編輯app/models/event.rb、app/models/group.rb和app/models/event_groupship.rb：
class Event < ActiveRecord::Base
    has_many :event_groupships
    has_many :groups, :through => :event_groupships #关键
end

class EventGroupship < ActiveRecord::Base
    belongs_to :event #关键
    belongs_to :group
end

class Group < ActiveRecord::Base
    has_many :event_groupships
    has_many :events, :through => :event_groupships #关键
end

範例，建立雙向關聯記錄:
  g = Group.create( :name => 'ruby taiwan' )
  e1 = Event.first
  e2 = Event.create( :name => 'ruby tuesday' )
  EventGroupship.create( :event => e1, :group => g )
  EventGroupship.create( :event => e2, :group => g )
  g.events
  e1.groups
  e2.groups

比较复杂的多对多关联 写campus_net时候的user has_many temp_relation, temp_relation里receiver和requestor_id都是对应User

User model
has_many :temp_relations, foreign_key: :receiver_id
has_many :request_friends, through: :temp_relations, foreign_key: :requestor_id, source: :requestor

TempRelation model
belongs_to :receiver, foreign_key: :receiver_id, class_name: "User"
belongs_to :requestor, foreign_key: :requestor_id, class_name: "User"

#多态关联!!!#
有些model会被多个不同model has_many，例如picture 可以同时属于 employee 和 product，那么就可以使用polymorphic多态
写法
    class Picture < ActiveRecord::Base
      belongs_to :imageable, :polymorphic => true
    end
     
    class Employee < ActiveRecord::Base
      has_many :pictures, :as => :imageable
    end
     
    class Product < ActiveRecord::Base
      has_many :pictures, :as => :imageable
    end
#这样用@employee.pictures就可以拿取到所要的pictrue, @pictrute.imageable也可以拿取到所属的model

生成表是这样:
#分别有一个id和一个type,id就是所属的model_id, type就是所属model的类型
class CreatePictures < ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end
end
#可以使用 t.refernces 更方便
class CreatePictures < ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, :polymorphic => true
      t.timestamps
    end
  end
end

# 关联参数和方法 #
a）class_name
  belongs_to :manager, :class_name => "User" # 外部鍵是user_id
b)可以變更Foreign Key的欄位名稱，例如改成manager_id：
  belongs_to :manager, :class_name => "User", :foreign_key => "manager_id"
c)order has_many可以透過:order參數指定順序：
  has_many :attendees, :order => "id desc"
d)dependent 可以設定當物件刪除時，也會順便刪除它的has_many物件：
    has_many :attendees, :dependent => :destroy
 #:destroy 會執行attendee的destroy回呼
 #:delete 不會執行attendee的destroy回呼
 #:nullify 這是預設值，不會幫忙刪除attendee
f)joins 和 includes 查詢
針對Model中的belongs_to和has_many關連，可以使用joins，也就是INNER JOIN
  Event.joins(:category)# SELECT "events".* FROM "events" INNER JOIN "categories" ON "categories"."id" = "events"."category_id"
可以一次關連多個：
  Event.joins(:category, :location)
joins主要的用途是來搭配where的條件查詢：
  Event.joins(:category).where("categories.name is NOT NULL")# SELECT "events".* FROM "events" INNER JOIN "categories" ON "categories"."id" = "events"."category_id" WHERE (categories.name is NOT NULL)
透過joins抓出來的event物件是沒有包括其關連物件的。
  Event.includes(:category)# SELECT * FROM events # SELECT * FROM categories WHERE categories.id IN (1,2,3...)
同理，也可以一次載入多個關連：
  Event.includes(:category, :attendees)
includes方法也可以加上條件：
  Event.includes(:category).where( :category => { :position => 1 } )

#!!! includes的nest写法 #
Category.includes(:posts => [{:comments => :guest}, :tags]).find(1)

#个人总结:join和includes的差别,例如一个user对多个post,join的作用是查post id为5的那个user，并不会取出post,include则会同时取出post#
# Consider these relations:
User has_many :posts
Post belongs_to :user

# Usage of joins/includes & where:
User.includes(:posts).where(posts: { name: 'BlogPost #1' })
                  #^            ^
Post.joins(:user).where(users: { name: 'Little Boby Table' })

!!如果要includes 关联model的某几个column,只能用下面这种hack

belongs_to :user_only_fetch_email, :select => "users.id, users.email", :class_name => "User"
#just i created one more association but it points to User model only. So you query will be,

Profile.includes(:user_only_fetch_email)
or
Profile.includes(:user_only_fetch_email).find(some_profile_ids)


# model中要注意的事项!!!#
1)controller中的cache问题
product.orders #第一次取出
product.orders.size #这时会使用cache, 不会再读库
product.orders(true).size #传个true给他的话就会强制读库，保证数据一致性

2)注意定义model类名不要和rails里ActiveRecord::Base里面的方法名重名， 这样很容易会重写掉方法,例如attribute, connection

3)创建关联时记得检查有没有在migration里面add_column做外键

4)has_and_belongs_to_many的问题， 一定要记得创建join_table，并且jointable不需要id
    class Assembly < ActiveRecord::Base
      has_and_belongs_to_many :parts
    end
     
    class Part < ActiveRecord::Base
      has_and_belongs_to_many :assemblies
    end

    class CreateAssemblyPartJoinTable < ActiveRecord::Migration
      def change
	create_table :assemblies_parts, :id => false do |t|
	  t.integer :assembly_id
	  t.integer :part_id
	end
      end
    end

5)命名在module里面的model的问题
在同一个module scope里面的两个model可以随便关联，但是在不同module的话就要注意，使用:class_name才行
    module MyApplication
      module Business
	class Supplier < ActiveRecord::Base
	   has_one :account,
	    :class_name => "MyApplication::Billing::Account"
	end
      end
     
      module Billing
	class Account < ActiveRecord::Base
	   belongs_to :supplier,
	    :class_name => "MyApplication::Business::Supplier"
	end
      end
    end


6)注意model 关联后取出来的同步问题
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # => true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # => false
#上述是因为ActiveRecord没有保存的话不能检测出关联的model的变动,可以使用:inverse_of去保证这东西数据一致（感觉上还是程序员要注意数据一致性要好）
    class Customer < ActiveRecord::Base
      has_many :orders, :inverse_of => :customer
    end
     
    class Order < ActiveRecord::Base
      belongs_to :customer, :inverse_of => :orders
    end
#--------
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # => true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # => true
#在through, polymorphic, as里面都不能用，只能用在belongs_to的model里面，像上面的orders, 有has_many的model也无能为力,所以还是不用的好



----------------------------------------------------------------------
八,验证 Validation
#检查取出的model是否为空#
u = User.find(1)
u.blank? #空的话返回true

#非空 validates_presence_of#
class Person < ActiveRecord::Base
 validates_presence_of :name
 validates_presence_of :login
 validates_presence_of :email
# validates_presence_of :name, :login, :email
end

#字符长度 validates_length_of#
class Person < ActiveRecord::Base
  validates_length_of :name, :minimum => 2 # 最少 2
  validates_length_of :bio, :maximum => 500 # 最多 500
  validates_length_of :password, :in => 6..20 # 介於 6~20
  validates_length_of :registration_number, :is => 6 # 剛好 6
end

# 确保是数字 validates_numericality_of#
class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, :only_integer => true # 必須是整數
  validates_numericality_of :age, :greater_than => 18
  #除了 greater_than，還有 greater_than_or_equal_to, equal_to, less_than, less_than_or_equal_to 等參數可以使用。
end

# 保证唯一 validates_uniqueness_of #
class Account < ActiveRecord::Base
  validates_uniqueness_of :email
end

class Holiday < ActiveRecord::Base
  validates_uniqueness_of :name, :scope => :year #确保相通的年份中，:name是要唯一的 
end 

#另外還有個參數是 :case_sensitive 預設是 true，表示要區分大小寫。

# 确保格式正确 validates_format_of(使用正则确保格式) #
class User < ActiveRecord::Base
    validates_format_of :email, :with => /\A([\w\.%\+\-]+)@([\w\-]+\.)+([\w]{2,})\z/i
    validates_format_of :url, :with =>  /(^$)|(^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?$)/ix
end

# 确保只能是某些值 validates_inclusion_of #
class Message < ActiveRecord::Base
    validates_inclusion_of :status, :in => ["pending", "sent"] #只能是pending和send
end
# validates_exclusion_of 确保不能是某些值

# 可共用的验证参数(可以用在上述的方法中) #
allow_nil => true  #允许null
allow_blank #允许是nil和空白字符串
message => "出错信息" # validates_uniqueness_of :email, :message => "你的 Email 重複了"
on => :create(or :update) => #设定在只有建立或者更新时才验证   validates_uniqueness_of :email, :on => :create

#出错信息的补充#
最好的方法：设置好:message后,先检验model.valid?，如果是false的话就可以看model.errors这个对象，里面的message就是前面set好的message

也可以用这种写法,然后在model.save!的时候捕捉Exception => e , e.message
validates_presence_of :name, :password, :email, :message => "#{:name} 不能为空"

@model.errors.full_messages 这个就是所有出错信息的数组组合！!!!



#rails3 里面的整合写法#
有多个值就用hash，:message直接放hash里面
validates :name,  :presence => true, 
                  :length => {:minimum => 1, :maximum => 254}
               
validates :email, :presence => true, 
                  :length => {:minimum => 3, :maximum => 254},
                  :uniqueness => true,
                  :email => true
validates :location, :presence => {:message=>'fuck off'}  #这种写message方法才正确，不用写什么true

#自己补充#
validates :email, :uninqueness => {:case_sensitive => false } #case_sensitive 默认是true， 设为false才是忽略大小写
#来自rails源码的例子
#   validates :password, :confirmation => true
#   validates :username, :exclusion => { :in => %w(admin superuser) }
#   validates :email, :format => { :with => /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i, :on => :create }
#   validates :age, :inclusion => { :in => 0..9 }
#   validates :first_name, :length => { :maximum => 30 }
#   validates :age, :numericality => true
#   validates :username, :presence => true
#   validates :username, :uniqueness => true

#!!验证还可以伴随条件判断
:if, :unless, :on, :allow_blank, :allow_nil and :strict can be given to one specific validator, as a hash:
validates :password, :presence => { :if => :password_required? }, :confirmation => true
Or to all at the same time:
validates :password, :presence => true, :confirmation => true, :if => :password_required?

# 自定义验证 #
使用 validate 方法傳入一個同名方法的 Symbol 即可。
validate :my_validation
private
def my_validation
    if name =~ /foo/
        errors[:name] << "can not be foo"
    elsif name =~ /bar/
        errors[:name] << "can not be bar"
    elsif name == 'xxx'
        errors[:base] << "can not be xxx"
  	end
end
#在你的驗證方法之中，你會使用到 errors 來將錯誤訊息放進去，如果這個錯誤是因為某一屬性造成，我們就用那個屬性當做 errors 的 key
#例如本例的 :name。如果原因不特別屬於某一個屬性，照慣例會用 :base。

# 验证Callback #
callback可以在储存过程中修正或加入自己的切面逻辑，通常用在三种情况中：1.在Validation驗證前後 2. 存入数据库前后 3. 删除数据库前后
以下是當一個物件儲存時的流程，其中1~7就是回呼可以觸發的時機：
  (-) save
  (-) valid
  (1) before_validation
  (-) validate
  (2) after_validation
  (3) before_save
  (4) before_create
  (-) create
  (5) after_create
  (6) after_save
  (7) after_commit
#另外還有after_rollback和after_commit這兩個回呼和Transaction交易有關。

# 举例 #
設定一個before_validation回呼設定預設值，其中的setup_default方法會在資料驗證前執行：
class Event < ActiveRecord::Base
    before_validation :setup_default

    protected
    def setup_default
        self.is_public ||= true
    end
end
#注意#
#1.回呼的方法最好放在protected或private下，確保只能由Model內部呼叫。
#2.before_validation和before_save的差別在於前者會經過Validation驗證。
#3.請避免before_開頭的回呼方法中，最後運算的結果不小心回傳false。這樣會中斷儲存程序。如果不確定的話，請回傳return true。這算是常見的地雷，而且不容易除錯(你會發現資料莫名地無法儲存成功)。

#上面是写的callback(hook)
#下面还有读的callback
after_initialize #任何new或从数据库读出来都触发
after_find #从数据库读出来后触发

after_find do |model|
    p "#{model.id}"
end

----------------------------------------------------------------------
九, ActiveRecord 进阶
STI 继承问题

# Transaction #
a)使用ActiveRecord::Base
ActiveRecord::Base.transaction do
  david.withdrawal(100)
  mary.deposit(100)
end

b)model对象本身内部也可以使用这种方式transaction
Account.transaction do
  balance.save!
  account.save!
end
#save and destroy are automatically wrapped in a transaction

c)exception
Number.transaction do
  Number.create(:i => 0)
  begin
    # This will raise a unique constraint error...
    Number.create(:i => 0)
  rescue ActiveRecord::StatementInvalid
    # ...which we ignore.
  end
  Number.create(:i => 1)
end

d)rollback
User.transaction do
  User.create(:username => 'Kotori')
  User.transaction(:requires_new => true) do
    User.create(:username => 'Nemu')
    raise ActiveRecord::Rollback #关键
  end
end
#only “Kotori” is created. (This works on MySQL and PostgreSQL, but not on SQLite3.)


Serialize
Observers

#Dirty objects#
Dirty Objects功能可以追蹤Model的屬性是否有改變：
person = Person.find_by_name('Uncle Bob')
person.changed?       # => false 沒有改變任何值
# 讓我們來改一些值
person.name = 'Bob'
person.changed?       # => true 有改變
person.name_changed?  # => true 這個屬性有改變
person.name_was       # => 'Uncle Bob' 改變之前的值
person.name_change    # => ['Uncle Bob', 'Bob']
person.name = 'Bill'
person.name_change    # => ['Uncle Bob', 'Bill']
# 儲存進資料庫
person.save
person.changed?       # => false 
person.name_changed?  # => false
# 看看哪些屬性改變了
person.name = 'Bob'
person.changed        # => ['name']
person.changes        # => { 'name' => ['Bill', 'Bob'] }


----------------------------------------------------------------------
十, ActionView
::Rails 的Template有两套引擎,erb和builder,html/js用erb,xml/rss/atom用builder，例如:
show.xml.builder的檔案：
    people do |p|
      p.person "test"
    end

::也有用HAML代替erb的(gem "haml-rails")，例如:
#content
  .box
    test
会生成
<div id="content">
  <div class="box">
    test
  </div>
</div>

# erb标签 #
<%%> <%= %> <% #单行注解 %> <%- 令程序不输出erb标签换行 -%>
<%output = false%>
  <% 多行注解%>
<% end %>

# layout #
用于每个页面共用的部分，预设在app/views/layouts/application.html.erb

a)controller指定layout
  class EventsController < ApplicationController
    layout "special"
  end
這樣就會指定Events Controller下的Views都使用app/views/layouts/special.html.erb這個Layout，你可以加上參數:only或:except表示只有特定的Action：
  class EventsController < ApplicationController
    layout "special", :only => :index
  end
或是：
  class EventsController < ApplicationController
    layout "special", :except => [:show, :edit, :new]
  end

b)使用symbol动态指定layout
class EventsController < ApplicationController
  layout :determine_layout
  private
  def determine_layout
    ( rand(100)%2 == 0 )? "event_open" : "event_closed"
  end
end

c)在action中指定layout
def show
   @event = Event.find(params[:id])
	render :layout => "foobar"
end
#更常见是直接render :layout=>false 关闭掉它

d)自定义layout
除了<%= yield %>會載入Template內容之外，我們也可以預先自定一些其他的區塊讓Template可以置入內容。例如，要在Layout中放一個側欄用的區塊，取名叫做:sidebar：
<div id="sidebar">
    <%= yield :sidebar %>
</div>
<div id="content">
    <%= yield %>
</div>
那麼在Template樣板中，任意地方放:
<%= content_for :sidebar do %>
   <ul>
       <li>foo</li>
       <li>bar</li>
   </ul> #/
<% end %>
然后就会放在#sidebar 里面

e)different layout in each action
class MyController < ApplicationController
  layout :resolve_layout
  private

  def resolve_layout
    case action_name
    when "new", "create"
      "some_layout"
    when "index"
      "other_layout"
    else
      "application"
    end
  end
end

# Partial局部样板 #
局部樣板可以將Templaet中重複的程式碼抽出來，例如我們在Part1中示範過的新增和編輯的表單。Partial Template的命名慣例是底線開頭，但是呼叫時不需加上底線，例如：
<%= render :partial => "common/nav" %>
這樣便會使用app/views/common/_nav.html.erb這個樣板。如果使用Partial的樣板和Partial所在的目錄相同，可以省略第一段的common路徑。

在Partial樣板中是可以直接使用實例變數的(也就是@開頭的變數)。不過好的實務作法是透過:locals明確傳遞區域變數，這樣程式會比較清楚，Partial樣板也比較容易被重複使用：
<%= render :partial => "common/nav", :locals => { :a => 1, :b => 2 } %>
#!!! 这里有一点点歧义！其实:locals不是关键字，意思是可以(render不明确指定:partial) <%= render "common/nav" :one_variable => {xxx}, :another_variable => {xxx} %>, 这样传参数
#如果像上面的例子明确指定partial => "xxx/xxx", 那么后面就要使用:locals 
#造成这个原因是render方法会检查，(:partial => xxx, :locals => xxx )这种是传入hash， 另外一种是第一个参数是string

#!!! 最新更新，有时如果partial里面也想要yield的话，一定要用  render :layout => 才可以接！很奇怪，直接render "xxx"是接不到的
  render layout:"layouts/modal" locals:{some:'some'} do
      <p>some</p> #这里才能接到partial的yield
  end


集合型Collection
像是tr或li這類會一直重複的Template元素，我們可以使用collection參數來處理，Rails有針對集合型的Partial做效率最佳化，例如像以下的程式：
<ul>
    <% @people.each do |person| %>
        <%= render :partial => "person", :locals => { :person => person } %>
    <% end %>
<ul>
可以改使用Collection方式，
<ul>
    <li><%= render :partial => "person", :collection => @people %></li>
<ul>
如此既可以少掉兩行each程式碼，執行的效能又更好。指定locals之后如上述例子可以直接在partial中直接使用person这个对象

#!!! get Controllername in view 在view 里获取controller 的名称
params[:controller]
params[:action]

----------------------------------------------------------------------
十一, ActionView Helper & Asset
Helper指的是可以在Template中使用的輔助方法，主要用途是可以將資料轉化成輸出用的HTML字串，例如我們已經用過了Rails內建的link_to方法，它可以將字串變成超連結。让我们更容易构建html

Asset（静态文件辅助方法）好处：
#Rails會合併Stylesheet和JavasSript檔案，可以加速瀏覽器的下載。
#Rails會編譯Sass和CoffeeScript等透過Assets template engine產生的Stylesheet和JavasSript
#Rails會在靜態檔案網址中加上時間序號，如果內容有修改則會重新產生。這樣的好處是強迫用戶的瀏覽器一定會下載到最新的版本，而不會有瀏覽器快取到舊版本的問題。
#變更Assets host主機位址時，可以一次搞定，例如上CDN時。透過Helpers，Rails可以幫所有的Assets加上靜態檔案伺服器網址。
几个常用tag：
javascript_include_tag
stylesheet_link_tag
image_tag
video_tag
audio_tag

# 常用辅助方法 #
a)simple_format 把回车变成<br>

b)truncate 输出概览，例如把文章输出第一段，后面长的用...补上, 省略号

c)sanitize 白名單逸出
預設允許的HTML標籤和屬性如下：
ActionView::Base.sanitized_allowed_tags
=> #<Set: {"strong", "em", "b", "i", "p", "code", "pre", "tt", "samp", "kbd", "var", "sub", "sup", "dfn", "cite", "big", "small", "address", "hr", "br", "div", "span", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "li", "dl", "dt", "dd", "abbr", "acronym", "a", "img", "blockquote", "del", "ins"}>
ActionView::Base.sanitized_allowed_attributes
=> #<Set: {"href", "src", "width", "height", "alt", "cite", "datetime", "title", "class", "name", "xml:lang", "abbr"}>
如果需要增加，可以在config/application.rb中新增，例如：
  config.action_view.sanitized_allowed_tags = %w[table tr td]
  config.action_view.sanitized_allowed_attributes = "rel"

d)strip_tags 移除HTML標籤

e)strip_links 移除HTML超連結標籤

#各种辅助方法#
a）URL輔助方法
link_to #文字超連結
mail_to #E-mail
button_to #按鈕連結

b）自定標籤輔助方法
tag
content_tag

#来自rails文档的content_tag example#
content_tag(:p, "Hello world!")
 # => <p>Hello world!</p>
content_tag(:div, content_tag(:p, "Hello world!"), :class => "strong")
 # => <div class="strong"><p>Hello world!</p></div>
content_tag("select", options, :multiple => true)
 # => <select multiple="multiple">...options...</select>

<%= content_tag :div, :class => "strong" do -%>
  Hello world!
<% end -%>
 # => <div class="strong">Hello world!</div>

c）其他輔助方法 !!
escape_javascript 输出javascript可用的字符串, 简写可以用 alias j() 
debug
number_to_currency

d)表单辅助方法
对应model的：
<%= form_for @event do |f| %>
    <%= f.text_field :name %>
    <%= f.submit %>
<% end %>

自定义的:
<%= form_tag "/search" do %>
    <%= text_field_tag :keyword %>
    <%= submit_tag %>
<% end %>

常用表单辅助方法：
text_field
text_area
radio
check_box
select
select_date, select_datetime
submit

#fields_for 表单关联model的属性设定 (在simple_form里面是simpe_fields_for)#
假设 user has_one setting
<%= form_for @user do |f|%>
   #....blahblah user attribute
    <%= fields_for @setting do |ff|%> 
	<%= ff.text :blog_name %>
    <%end%>
<%end%>

# 自定义helper #
要建立自定的Helper，只需要將方法定義在app/helpers/目錄下的任意檔案就可以了。在產生Controller的同時，Rails就會自動產生一個同名的Helper檔案，照慣例該Controller下的Template所用的Helper，就放在該檔案下。如果是全站使用的Helper，則會放在app/helpers/application_helper_rb，例如：
module ApplicationHelper
    def gravatar_url(email)
     gravatar_email = Digest::MD5.hexdigest(email.downcase)
     return "http://www.gravatar.com/avatar/#{gravatar_email}?s=48"
    end
end
如此便可以在Template中這樣使用：
  <%= image_tag gravatar_url(user.email) %>
Helper是全域的，定義在哪一個檔案中沒有關係，檔案名稱也不需要與Controller名稱對應。

----------------------------------------------------------------------
十二, 静态档案和 Ajax
Rails 3.1引進了一項新功能叫做Assets pipeline，這個功能可以讓我們突破public目錄限制，可以將靜態檔案依需求放在不同目錄下，Rails會幫你組合並壓縮起來。特別是有一些Rails的外掛套件需要使用JavaScript等靜態檔案，在沒有這個功能之前，我們必須將JavaScript等檔案複製放在public目錄下，這樣瀏覽器才能讀取的到。

Assets的位置在app/assets/下，首先最重要的就是app/assets/javascripts/application.js和app/assets/stylesheets/application.css，
這兩個檔案看起來充滿註解，其實它是個manifest檔案，列出了所有要載入的靜態檔案，這些檔案的位置依照慣例放在app/assets或vendor/assets目錄下。
#=require_tree意思是javascripts目录下的所有js文件都会合并

# 处理图片网址 #
放在app/assets/images下的圖片該怎麼使用呢？在實際佈署後，Rails會將檔案名稱加以編碼，例如rails.png會變成rails-bd9ad5a560b5a3a7be0808c5cd76a798.png。在一般的View中，可以使用image_tag這個Helper：
<%= image_tag("rails.png") %>
如果在CSS裡的話，有兩種辦法：一是將檔案命名為erb結尾，例如app/assets/stylesheets/main.css.erb，然後使用asset_path這個Helper：
  h1 {
    background-image: url('<%= asset_path("rails.png") %>');
  }
另一種方法是使用Sass或SCSS語法。其中SCSS相容於CSS。例如命名為app/assets/stylesheets/main.css.scss，然後使用image-url這個Sass提供的方法：
  h1 {
    background-image: image-url("rails.png")
  }
如果是js檔案中想要拿圖片的位置，就只能用js.erb的格式，然後內嵌asset_path Helper方法了。

# 编译Assets #
開發的時候，Rails會自動將Asset的壓縮結果快取在tmp下，rake指令可以產生出來：
    rake assets:precompile #產生出來的檔案在public/assets/下
    rake assets:clean #这样可以清除assets

# 自定义Assets方案，使用指定文件 #
上述的application.js或application.css中，預設會壓縮所有app/assets目錄下的檔案，如果你需要拆開，只需要修改其中的內容把require_tree那行移除，那麼就只會壓縮你所指定的目錄或檔案。

：：例如，要新增新的Manifest檔案的話，
1）假設叫做app/assets/javascripts/search.js，內容如：
//= require ./foobar
2）這樣就會將assets/javascripts/foobar這個目錄下的檔案通通壓縮成search.js，而在View中：
<%= javascript_include_tag "application" %>
<%= javascript_include_tag "search" %>
就會載入。注意到如果啟用了assets功能，javascript_include_tag只能接受一個參數，即Manifest檔案的名稱。
3）為了讓rake assets:precompile也能產生新的壓縮檔案，你還需要編輯config/environments/production.rb加入：
config.assets.precompile += %w( search.js )

# 关闭Assets功能 #
也可以不使用這個功能，請修改config/application.rb將以下設定改成false：
    config.assets.enabled = false
這樣的話，在View中就必須列出所有你要載入的Script檔案：
    <%= stylesheet_link_tag    "reset", "application", :cache => "all" %>
    <%= javascript_include_tag 'jquery', 'rails', 'application', :cache => "all" %>
這些檔案都必須放在public目錄下。而加上cache參數Rails會合併這些檔案，但是並不會壓縮。

#link_to ajax #
在link_to 或者button 加remote => true就行
<%= link_to 'ajax show', event_path(event), :remote => true, "data-type" => :json, :id => "update_foobar" %>
JS代码:
$(function() {
    $('#update_foobar').bind("ajax:success", function(event, data) {            
        var foobar = $('#foobar');
        foobar.html( data.foobar_number );
    });
});

#还有几种 ajax的事件#
ajax:before – right before ajax call
ajax:loading – before ajax call, but after XmlHttpRequest object is created)
ajax:success – successful ajax call
ajax:failure – failed ajax call
ajax:complete – completion of ajax call (after ajax:success and ajax:failure)
ajax:after – after ajax call is sent (note: not after it returns)

#继续补充!! 
#rails3开始有的ujs(unobtrusive javascript)
data-confirm 会弹出用户提示
data-method 上传方法
data-remote 是否使用ajax
data-disable-with 上传过程中另dom失效

<a href="/posts/2" class="delete_post" data-confirm="Are you sure?" data-method="delete" data-remote="true" rel="nofollow">Destroy</a>
这样写可以产生一个需要确认,方法是delete,ajax的连接

在post controller show里头
def show
    # xxx action
    respond_to do|format|
      if @post.save  
        format.html { redirect_to(@post, :notice => 'Post created.') }  
        format.js  
      else  
        format.html { render :action => "new" }  
        format.js  
      end  
    end
end
这时候，如果没有明确指定返回js的动作，就会默认找一个叫post/show.js.erb,这个文件可以直接用javascript+erb的代码返回到前端!! 这就是rails的erb ajax方式，另外还有上面之前写的ajax:success的完全客户端方式，erb方式更容易处理前端代码,但是不能使用coffeescript
$("body").append("<%= @post.content %>")

rails ajax 强化自定义
打开jquery-rails 这个gem，会发现有jquery-ui, jquery_ujs, 要改ajax行为主要是修改这个包里面提供的custom方法
// Default confirm dialog, may be overridden with custom confirm dialog in $.rails.confirm
confirm: function(message) {
        return confirm(message);
}
我们在application时先复写这个方法，就可以用更好的例如bootstrap modal 或 tooltip去取缔他
#For 'data-confirm' attribute:
#- Fires `confirm` event
#- Shows the confirmation dialog
#- Fires the `confirm:complete` event

#Returns `true` if no function stops the chain and user chose yes; `false` otherwise.
#Attaching a handler to the element's `confirm` event that returns a `falsy` value cancels the confirmation dialog.
#Attaching a handler to the element's `confirm:complete` event that returns a `falsy` value makes this function
#return false. The `confirm:complete` event is fired whether or not the user answered true or false to the dialog.









----------------------------------------------------------------------
十三, Restful 表单设计
willdo

----------------------------------------------------------------------
十四, I18N
1)config/locales 下，使用 yml 格式。Rails 預設的語系是英文，如果要換成中文，請這樣做：
  下載 zh-TW.yml http://github.com/svenfuchs/rails-i18n 到 config/locale/ 下，就有預設的 Rails 繁體中文翻譯
修改 config/application.rb 的預設語系
  config.i18n.default_locale = "zh-TW"

2)使用I18n.t這個方法來做翻譯詞彙的替換。而在 View 中可以直接使用 t 方法。翻譯關鍵字可以用字串或 Symbol，也可以加上 Scope，例如:
t("admin.event")
t(:event, :scope => :admin )
搭配的 yml 設定範例：
"zh-TW"
  admin:
    event: 活動
注意 YAML 格式的縮排必須使用兩個空隔，Tab 是不允許的。直接複製貼上可能會有問題，請重新縮排過。

3)要在詞彙內嵌的話，可以使用%{variable_name}：
"zh-TW"
    hello: "親愛的%{name}你好!"
在樣板中傳入參數即可：
    t(:hello, :name => @user.name) # 親愛的XXX你好

4)搭配Model使用
在套用上述的翻譯詞彙檔之後，你可能會注意到Model驗證錯誤訊息會變成如Name 不能是空白字元，如果需要近一步中文化欄位名稱，你可以新增config/locales/events.yml內容如下：
zh-TW:
  activerecord: 
    attributes:
      event:
        name: "活動名稱"
        description: "描述"
其實，翻譯檔檔名叫events.yml、zh-TW.yml、en.yml什麼都無所謂，重要的是YAML結構中第一層要對應locale的名稱，也就是zh-TW，Rails會載入config/locales下所有的YAML詞彙檔案。

5)時區 TimeZone
a)首先，資料庫裡面的時間一定都是儲存 UTC 時間。而 Rails 提供的機制是讓你從資料庫拿資料時，自動幫你轉換時區。例如，要設定台北 +8 時區：
    首先設定 config/application.rb 中預設時區為 config.time_zone = “Taipei”，如此 ActiveRecord 便會幫你自動轉換時區，也就是拿出來時 +8，存回去時 -8
b)如何根據使用者切換時區?
    首先，你必須找個地方儲存不同使用者的時區，例如 User model 有一個欄位叫做 time_zone:string。然後在編輯設定的地方，可以讓使用者自己選擇時區:
 <%= time_zone_select 'user','time_zone' %>
接著在 application_controller.rb 中加入:
before_filter :set_timezone		
def set_timezone
   if logged_in? && current_user.time_zone
      Time.zone = current_user.time_zone
    end
end
c)Rails中的時間類別使用的是ActiveSupport::TimeWithZone，我們已經知道可以使用Time.zone可以改變時區，其他的用法例如：
Time.zone = "Taipei"
Time.zone.local(2011, 8, 3, 9, 0) # 建立一個Taipei當地時間
=> Wed, 03 Aug 2011 09:00:00 CST +08:00
t = Time.zone.now # 目前時間
=> Wed, 03 Aug 2011 22:17:54 CST +08:00
t.in_time_zone("Tokyo") # 將這個時間換時區
=> Wed, 03 Aug 2011 23:18:34 JST +09:00
Time.utc(2005,2,1,15,15,10).in_time_zone # 將UTC時間換Taipei當地時間
=> Tue, 01 Feb 2005 23:15:10 CST +08:00

----------------------------------------------------------------------
十五, ActionMailer
Rails在config/environments目錄下針對不同執行環境會有不同的郵件伺服器設定：
  config.action_mailer.delivery_method = :test
#支援的選項包括:test、:sendmail和smtp。在config/environments/test.rb中，預設是:test，也就是並不會實際寄信，而是將信件存在ActionMailer::Base.deliveries陣列中方便做功能測試。sendmail則是使用伺服器的/usr/bin/sendmail程式，不過因為因為不是每台伺服器都有適當安裝sendmail，所以最推薦的方式是採用:smtp協定來寄信

1)使用SMTP用Gmail发信：
用Gmail寄信的範例，請修改config/environments/development.rb或config/environments/production.rb：

config.action_mailer.smtp_settings = {
    :address => "smtp.gmail.com",
    :port => "587",
    :domain => "gmail.com",
    :authentication => "plain",
    :user_name => "example@gmail.com",
    :password => "123456",
    :enable_starttls_auto => true
 }

2)Mailer发送实例
 
a）
 rails generate mailer UserMailer confirm #如此便會產生 app/mailers/user_mailer.rb 檔案，並包含一個 confirm 的動作，其 template 在 app/views/user_mailer/ 下，也就是 confirm.text.erb (純文字格式)或 confirm.html.erb (HTML格式)。如果兩種格式的樣板檔案都有，那麼Rails會合併成一封Multiple Content Types的Email。


b)user_mailer.rb 的程式：
class UserMailer < ActionMailer::Base  
    default :from => "foobar@example.org"  
    def confirm(email) #收件人
        @message = "Thank you for confirmation!" #这个变量在view里面可以直接读取
        mail(:to => email, :subject => "Registered")   #设定收件人和主题
    end  
end  

c)我們可以在 rails console 中測試，執行 
    UserMailer.confirm(“someone@example.org”).deliver #发信
d)通常在注册后发信
def create
    user = User.new(params[:user])
    if user.save
        UserMailer.confirm(user.email).deliver
        redirect_to users_path
    else
        render :action => :new
    end
end

----------------------------------------------------------------------
十六, Rails其他

1）JSON处理
ActiveSupport::JSON.encode( [ {:a => 1 , :b => 2 } , "c", "d" ] )#=> "[{\"a\":1,\"b\":2},\"c\",\"d\"]" 	
ActiveSupport::JSON.decode( "[{\"a\":1,\"b\":2},\"c\",\"d\"]" ) #=> [{"a"=>1, "b"=>2}, "c", "d"] 

Yajl-ruby 則是一套底層用C，比較快的 JSON parser。如果要替換 Rails 內建的 JSON 函式庫，請在 config/application.rb 最下方加入：
 ActiveSupport::JSON.backend = 'Yajl'

2）pdf
Prawn 可以產生 PDF，支援 Unicode。
PDFKit 則是另一個有趣的產生方式，透過 HTML/CSS 轉 PDF。

3)表單
除了用Rails內建的表單Helper，也有一些提供表單設計更方便的套件：
simple_form
formtastic

4)分頁
will_paginate
kaminari

5)檔案上傳
有兩套選擇：
Paperclip 是目前使用上最為方便的檔案上傳 plugin。
CarrierWave

6)如何畫圖表
使用 GoogleCharts 是最簡單的方式。 如果您使用 jQuery，flot 是一套不錯的圖表工具

7)ssl
ssl_requirement 可以幫助您設定哪些頁面只能只用 HTTPS 或 HTTP 連線。

8)升级Rails
小版號的升級，通常透過以下步驟即可完成：
  修改Gemfile的Rails版本： gem 'rails', '3.1.1'
  執行bundle update
  執行rake rails:update 會嘗試更新Rails自己產生的檔案，例如config/boot.rb，請一一手動檢查。

9)rake
rake的各种方法
  rake db:migrate
  rake db:drop
  rake tmp:clear
  rake notes
你可以輸入 rake -T 看到所有的 rake 指令。而要在 Rails 環境中撰寫 Rake，請將附檔名為 .rake 的檔案放在 lib/tasks 目錄下即可，例如：
/lib/tasks/dev.rake

##！！利用rake执行周期性任务
如果您有週期性的任務需要執行，也可以透過crontab設定去執行rake腳本。例如輸入crontab -e加入：
  0 2 * * * cd /home/your_project/current/ && RAILS_ENV=production /usr/local/bin/rake cron:daily
就是每天凌晨兩點執行rake cron:daily這個任務。


----------------------------------------------------------------------
十七, Test 测试
使用进化的RSpec 取代 Test::Unit

UnitTest 和 RSpec语法对比：
Unit：
class OrderTest < Test::Unit::TestCase
  def setup
    @order = Order.new
  end

  def test_order_status_when_initialized
    assert_equal @order.status, "New"
  end

  def test_order_amount_when_initialized
    assert_equal @order.amount, 0
  end
end
RSpec:
describe Order do
  before do
    @order = Order.new  
  end

  context "when initialized" do
    it "should have default status is New" do
      @order.status.should == "New"
    end

    it "should have default amount is 0" do
      @order.amount.should == 0  
    end
  end
end

# RSpec范例 #
1）Gemfile：
group :test, :development do
  gem "rspec", "~> 2.0"
  gem "rspec-rails", "~> 2.0"
end

2）安装：
  rails generate rspec:install

3）执行测试：
  bundle exec rake spec #rake spec會先執行一次rake db:test:prepare建立測試資料庫。
測試單一檔案，例如：
bundle exec rspec spec/models/user_spec.rb

4)语法基本用法
#describe和context幫助你組織分類，都是可以任意套疊的：#
#describe "#method",可以是代表专门测试一个实例方; context "when open",context则是这个方法的不同情况,每一个it就是一个小测试
describe Order do
  describe "#amount" do  
    context "when user is vip" do
     # ...
    end

    context "when user is not vip" do
      # ...
    end
  end
end

# it和should #
每個it就是一小段測試，在裡面我們會用should來設定期望，例如：
describe Order do
  describe "#amount" do  
    context "when user is vip" do
      it "should discount five percent if total >= 1000" do
        user = User.new( :is_vip => true )
        order = Order.new( :user => user, :total => 2000 )
        order.amount.should == 1900
      end
  
      it "should discount ten percent if total >= 10000" { ... }      
    end    
    context "when user is vip" { ... }    
  end
end

# before和after #
如同xUnit框架的setup和teardown：
  before(:each) 每段it之前執行
  before(:all) 整段describe前只執行一次
  after(:each) 每段it之後執行
  after(:all) 整段describe後只執行一次
 例如：
  before(:each) do
        @user = User.new( :is_vip => true )
        @order = Order.new( :user => @user )
  end

# pending #
pending 可以先列出來打算要寫的測試：
it "should be true if status is paid or shipping" do
    pending
end    

# Matcher # 很方便！
should 后面可以跟各种方便的matcher(类似link_to里面的Helper)
target.should be_true # targer.should == true
target.should be_false # targer.should == false
target.should be_nil # targer.should == nil
类别和方法：
target.should be_a_kind_of(Array) # target.class.should == Array
target.should be_an_instance_of(Array) # target.class.should == Array
target.should respond_to(:foo) # target.repond_to?(:foo).should == true
array和hash
target.should have_key(:foo) # target[:foo].should_not == nil
target.should include(4) # target.include?(4).should == true
target.should have(3).items # target.items.length == 3

# expect to #
 期待抛出exception,语法 expect {}.to xxx
   context "with paid" do
     it "should update status to shipping" do
       expect {
         order.ship!
       }.to change { order.status }.from("new").to("shipping")
     end
   end

#期待丢出例外
context "with paid" do
      it "should raise NotPaidError" do
       expect {
          order.paid? = false
          order.ship!
        }.to raise_error(NotPaidError)
      end
    end  

# let 懒加载，可以需要的时候才用到，可以增加测试的速度,let!则是立即加载#
describe "test let" do
   context "hell yeah" do
       let(:users) {User.find(:all)}
       it "users.size" do
         users.size.should > 5
       end
   end
end

#更高级应用#
1)使用subject可以省略receiveer
describe "sth" do
  subject {Order.new(name:'fun')}
  it{should !== nil}
end

2)its可以省略receiver的方法
    subject {xxx}
    its(:hi) {should == 0} #xxx.hi.should == 0

# RSpec Mocks #
专用于生成假资料，例如要使用平台的接口

-------
# Rails中使用RSpec#
1)rails g rspec:install #生成spec目录后原来test目录就不用了

2）新增spec/models/event_spec.rb如下：
require 'spec_helper'
describe Event do
  before do
    @event = Event.new( :name => "foobar" )
  end

  describe ".open?" do
    it "should return true if status is OPEN" do
      @event.status = "OPEN"
      @event.open?.should be_true
    end

    it "should return false if status is not OPEN" do
      @event.status = "CLOSED"
      @event.open?.should be_false
    end
  end
end
輸入bundle exec rake spec就會根據目前的開發資料庫Schema建一個測試用資料庫，然後執行所有spec目錄下的_spec.rb檔案結尾的測試。你也可以單獨執行測試bundle exec rspec spec/models/event_spec.rb。

-----使用guard-spec spork-----
边编程边快速自动测试
guard是一个监控文件变动的gem，spork是一个drb server,可以另ruby的单元测试更快速
几个gem配合使用详细参考gu-da项目,要修改的地方有Guardfile spec/spec_helper.rb
---------------------
Controller 的测试
这个例子还要用到mocha,在spec_helper里面加上config.mock_width :mocha
mocha是一个轻松模拟http事件的gem,也有一个javascript框架也叫mocha

class ArticlesController extend ActionController::Base
  def create
    @article = Article.new([params:id])
    if @article.save
      flash["notice"] = 'successful'
      redirect articles_path
    else
      render :new
  end

end
describe ArticlesController,"creating a new article" do
  render_views #这行代表一直要把views的代码也执行完，保证不出错 integrate_views已过时
  fixtures :article #这里可以换成factory_girl只要你喜欢 
  
  it "successful create" do
    #这里用了mock，像上面的controller里Article.new(params[:id]) blahblah的，这一句肯定正确，但是要可能走库,但用mock这样写这一句就可以过去了
    Article.any_instance.stubs(:valid?).returns(:true) #stub!的意思是把一切要检测valid的东西都给我显示个true
    post 'create', :article => {title:'blah',content:'blah'} #可以post params过来
    flash[:notice].should_not_be nil
    response.should redirect_to(articles_path)
  end

  it "fail create" do
    Article.any_instance.stubs(:valid?).returns(false) #就这里改成false
    post 'create'
    flash[:notice].should be_nil
    response.should render_template(:new)
  end
end

mock stub double都是用于创造假资料，官方貌似推荐用double，底层其实都是调用stub，理由是语义方面更好
Article.should_receive(:create).with(title:"hello",content:"shit").and_return(true) 这里首先指定这里controller Article model里面会收跑create, 接收参数，然后麻烦都给我返回true
controller_spec里面的assigns(:article)相当于articles_controller里面的@article实例变量

#对于stub和mock的新解释
驭件(mock)和桩件(stub)及其背后的概念如果不能写成一本书,也可以写成很长的单 独一章。在网上搜索,会不可避免的看到很多争论,辨析二者正确地用法。也会看到很多 人试图定义这两个概念。对我来说,二者最佳定义如下:
• 驭件是用来替代真实对象的测试对象,也被称为“测试替身”(test double)。驭件有 点类似通过 Factory Girl 生成的对象,但不会改动数据库中的数据。所以速度快一些。
• 桩件是对指定对象方法的重写,返回一个预设的值。也就是说,桩件虽是个虚假方 法,但调用时会返回一个真实的值供测试使用。桩件经常用来重写方法的默认功能, 特别是在频繁操作数据库或网络密集型交互中。


##自定义rspec
# spec/support/spec_test_helper.rb
module SpecTestHelper   
  def login_admin
    login(:admin)
  end

  def login(user)
    user = User.where(:login => user.to_s).first if user.is_a?(Symbol)
    request.session[:user] = user.id
  end

  def current_user
    User.find(request.session[:user])
  end
end
# spec/spec_helper.rb
RSpec.configure do |config|
    config.include SpecTestHelper, :type => :controller
end

这样在任意spec都可以使用 login(:user)
----------------------------------------------------------------------
十八, 性能问题 
# ActiveRecord #
观察SQL输出，尽量做到一次查询
1）尽量使用select,不用取的就不去取
  Event.find(:all, :select => "id, title, description")
搭配 named_scope 我們可以把常用的 :select 預先設定好，例如：
  class User < ActiveRecord::Base
    named_scope :short, :select => "id, name, email"
  end
  User.short.find(:all)

2）使用 :INCLUDE
使用 :include 避免 N+1（多个sql语句查询） 次 queries 的問題。
  @events = Event.find(:all, :include => [:group] )
  @events.each do |e|
    e.group.title
  end
如果沒有加 :include 把相關的 groups 一起載入，在迴圈中就會產生 @event.size 次對 group 的個別 SQL 查詢，會非常傷。加了 :include 之後總共只需查詢兩次。

另外一個比較少人知道的是，在設定 Model associations 時，如果有很明顯的情境一定會順道載入二階 association model，可以設定 :include 在 has_many, belongs_to, has_one 上面，例如：
  class User < ActiveRecord::Base
    has_one :foo, :include => [:bar]
  end
如此便會在載入 @user.foo 的同時，也會提早載入 @user.foo.bar。

3）加索引
針對 foreign key 要加上資料庫索引 index。在 migration 上透過 add_index 就可以加上去了。

4)特定情況下可用 :JOINS 取代 :INCLUDE
在只需要用到 :conditions 而不需要載入該 model 的情況下，可以用 :joins 取代 :include。
  Group.find(:all, :include => [ :group_memberships ], :conditions => [ "group_memberships.created_at > ?", Time.now - 30.days ] ) #使用:joins不应该用:include

5）直接自己写sql
ActiveRecord 可以直接寫 find_by_sql。

6）在要统计的地方直接添加一个字段用于存放计数器

#全文搜索#
Sphinx全文搜尋引擎和thinking_sphinx gem
Apache Solr(Lucenel)全文搜尋引擎和Sunspot gem
Xapian全文搜尋引擎和xapit gem
PostgreSQL內建有全文搜尋功能，可以搭配 texticle
Ferret和acts_as_ferret gem。Ferret是一套純用Ruby實作的全文搜尋引擎。


----------------------------------------------------------------------
十九, 安全问题 
1）预防javascript注入，过滤html输出（rails3自动做）：
  "<p>safe</p>".html_safe  
  raw("<p>safe</p>")
允许用户使用html标签sanitize()

2）预防CSRF resource攻击
有人会这样写去令你删除资料
<img src="/posts/delete_all">
所以后台要定义好rest，只有post put delete才能更改资料
rails的post会在view生成验证码，Layout中也有一段<%= csrf_meta_tags %>是給JavaScript讀取驗證碼用的。

3）sql注入
在Rails ActiveRecord的where方法中使用Hash或Array寫法就會幫你處理，所以請一定都用這種寫法，而不要使用上述的字串參數寫法：
  Project.where( { :name => params[:name] } )
  Project.where( ["name = ?", params[:name] ] )

4)!!!!!注意在model中使用attr_accessible(白名单) 和 attr_protected (黑名单),限制可读的字段，最好使用白名单，github也是这样被人黑了

----------------------------------------------------------------------
二十, 网站部署
選擇一：全自動模型 Apache/Nginx + Passenger 
Passenger又叫做mod_rails，是目前佈署Ruby on Rails最好用、設定最簡單的方式，它是一套Apache和Nginx的擴充模組，可以直接支援Rails或任何Rack應用程式。

#apache pessenger#
1)假设已经安装好apache：
  sudo gem install passenger
  sudo passenger-install-apache2-module
2)/etc/apache2/conf.d/mod_rails檔案之中，例如：
  passenger_module /usr/local/lib/ruby/gems/1.8/gems/passenger-3.0.7/ext/apache2/mod_passenger.so #模块位置
  PassengerRoot /usr/local/lib/ruby/gems/1.8/gems/passenger-3.0.7 #gem位置
  PassengerRuby /usr/local/bin/ruby #ruby位置
3)在httpd.conf加入
  <VirtualHost *:80>
      ServerName www.yourhost.com
      DocumentRoot /somewhere/public
    <Directory /somewhere/public>
      AllowOverride all
      Options -MultiViews
    </Directory>
  </VirtualHost>
4）重启问题
如果之後你的Rails有任何修改要重新載入，但是並不想把Apache重開，請在你的Rails應用程式目錄下執行touch tmp/restart.txt即可，這樣Passenger就會知道要重新載入Rails，而不需要重開Apache。

# Nginx + Passenger #
1）要讓Nginx裝上Passgener不需要先裝Nginx，只需要執行以下指令：
  sudo passenger-install-nginx-module
2）修改/opt/nginx/conf/nginx.conf，將server那段改寫成如下：
  server {
    listen       80;
    server_name  www.yourhost.com;
    root /somewhere/public;
    passenger_enabled on;
  }

選擇二：反向代理(Reverse proxy)模型 Apache/Nginx + Thin/Unicorn

# 自动化部署 #
Capistrano 是Rails 社群中最常使用的佈署工具
1）sudo gem install capistrano
2）在你的Rails目錄下執行：
  capify .
3）打開config/deploy.rb 
require 'bundler/capistrano'
# require 'hoptoad_notifier/capistrano'
set :application, "your-project-name"
set :branch, "master"
set :repository,  "git@github.com:ihower/your-project-name.git"
set :scm, "git"
set :user, "rails" # 一個伺服器上的帳戶用來放你的應用程式，不需要有sudo權限，但是需要有權限可以讀取Git repository拿到原始碼
set :port, "22"
set :deploy_to, "/home/rails"
set :deploy_via, :remote_cache
set :use_sudo, false
role :web, "111.222.333.444"
role :app, "111.222.333.444"
role :db,  "111.222.333.444", :primary => true

namespace :deploy do
  task :copy_config_files, :roles => [:app] do
    db_config = "#{shared_path}/database.yml"
    run "cp #{db_config} #{release_path}/config/database.yml"
  end
  
  task :update_symlink do
    run "ln -s {shared_path}/public/system {current_path}/public/system"
  end
  
  task :start do ; end
  task :stop do ; end
  task :restart, :roles => :app, :except => { :no_release => true } do
    run "#{try_sudo} touch #{File.join(current_path,'tmp','restart.txt')}"
  end
end
# after "deploy:update_code", "deploy:copy_config_files" # 如果將database.yml放在shared下，請打開
# after "deploy:finalize_update", "deploy:update_symlink" # 如果有實作使用者上傳檔案到public/system，請打開

4)設定好伺服器的資料之後，在本地端輸入：
  cap deploy:setup #就會自動登入遠端的伺服器，在登入的帳號下新建current、releases和shared這三個目錄，releases是每次佈署的紀錄，而current目錄則是用symbolic link指向releases目錄下最新的版本。

5)第一次部署，也是在本地端執行：
  cap deploy:cold #伺服器上的帳號需要有可以git clone專案的讀取權限。

6）之後要佈署，只需要執行：
  cap deploy


#處理Log檔案#
網站持續運作，log目錄下的production.log可是會越長越肥，因此需要定期整理備份，這裡有幾種方法，一種是修改config/environments/production.rb的設定：
  config.logger = Logger.new(config.paths["log"].first, 'daily') # 或 weekly,monthly
  config.logger = Logger.new(config.paths["log"].first, 10, 10*1024*1024) # 10 megabytes 

----------------------------------------------------------------------
二十一, rails 最佳实践
1）把重复的代码逻辑从controller移到model,例如在controller中的Posts.find(:all :condition{xxxxx}),可以把这个condition移动到post model里面用 named_scope

2)当有表关联时，尽量利用好表关联，例如user 一对一 post
不要:
  @post = Post.new(params[:post])
  @post.user_id = current_user.id
  @post.save
要：
  @post = current_user.posts.build(params[:post])

3)别做不必要的检查 #不要!
if @post.user != current_user
  flash[:notice "用户错"] #错误方式！！
end #wrong!

@post = current_user.posts.find(params[:post]) #这种正确，因为在关系中如果当前对象里面找不到post就直接会报错了

4）在一些fullname 对应 注册时的firstname lastname要使用虚拟属性

5）对于验证的方法，多用model callback (before_save,before_update之类)

6)model使用工厂方法创建对象来取代在 controller中用复杂的创建对象

7）活用Rest,Rest折叠，例如post包含comment
map.resources :posts do |post|
  post.resources :comments
end

8)把find放在自己的model里，例如要find comments，那应该放在comment里面不应该放在post里面

9）named_scope named_scope named_scope,常用这个

10)使用元编程 DRY

11）migration里面一定要加index，只要有需要都一定要加
add_index :comments, :post_id
add_index :comments, :user_id

12)在controller里面创建对象用切面写好
before_filter :build_post, :only => ['post','get']
def build_post
  @post = xxx
end

13)never logic code in views!

14)不要在model的after_create里面做不可以回滚的东西，因为after_create其实model还在callback当中,如果你after_create里面搞个发邮件，那model回滚了的话，数据库没东西，邮件缺发出去了



----------------------------------------------------------------------
二十二, Git
#Windows#
windows 的 Git 請安裝 msysgit。如果是透過 RailsInstaller 安裝，則已經附帶安裝好了。請參考以下步驟產生 SSH key：
  $ c:\RailsInstaller\Git\bin\ssh-keygen.exe -t rsa -C "your_email@example.org"
接著用文字編輯器打開 “%homedrive%%homepath%.ssh\id_rsa.pub” 的內容，即是你的 Public SSH key。

#git中文乱码问题#
git config core.quotepath false
#Ubuntu#
$  sudo apt-get install -y git-core
$  ssh-keygen -t rsa -C "your_email@youremail.com"

2）产生的key在 ~/.ssh/id_rsa.pub

3）編輯 "~/.gitconfig "
[user]
   name = Your Name
   email = your_email@youremail.com
[color]
   diff = auto
   status = auto
   branch = auto
   ui = auto
或者直接用命令：
git config --global user.name "ihower"
git config --global user.email "ihower@gmail.com"
git config --global github.user #usernameSets the GitHub username for all git instances on the system 
git config --global github.token 0123456789yourf0123456789token #设置token  !!!Github api V3 开始已经不需要设置token！！
git config --list #可以列出所有目前的设置
4）建立库
git init <dir_name> #會在本地新建一個 repo.。
git clone <remote_location> #會從遠端複製一份 repo 回來。

5）ADD, STATUS, COMMIT (WORKING TREE AND STAGING AREA)
  Working tree 是你當下的工作目錄，就像 SVN checkout 出來的工作目錄。這裡要特別學習的新概念是 Staging area，這是 Git 獨有的功能。它是一塊暫存的 cached 區域，用來紀錄什麼是你待會要 commit 檔案。
#add#
git add . #加入所有檔案，包括所有還沒有被追蹤(untracked)的檔案
git add -i #進入互動模式，你甚至可以只 Add 檔案裡面其中的一段程式碼到 staging area 去(稱作patch)
git add -u #只加更新的檔案，不加入還沒有追蹤的檔案 (跟 git commit -a 涵蓋的範圍相同)
#使用 git add 會將檔案加入 staging area 中，特別注意到待會的 commit 是 commit 你執行 add 時當下的檔案，而不是最後的版本。(也就是如果你 add 完之後又再次修改同個檔案，commit 出去的檔案是第二次修改前的版本)

#status#
最常用的 git status，會列出以下狀態：
.Changed but not updated 有修改但是沒有加入 staging area 的檔案
.Changes to be committed (staging area) 已經加入 staging area 的檔案
.Untracked 還沒有被追蹤的新檔案

#commit#
然後是 commit 指令，會把 Staging area 裡面的東西 commit 出去：
git commit -m "blah" #如果沒加 -m 的話, 會開編輯器輸入 commit log (可以在.gitconfig中設定編輯器)
git commit -a -m "foobar" #全部修改的檔案都 add 後 commit 出去 (不包括 untracked 的新檔案)
git commit -v #會開編輯器加上 diff 註解

#diff#
git diff # 是比較 working tree 跟 staging area
git diff --cached #是比較 staging area 跟本來的 repo.
git diff HEAD #是比較 working tree 跟本來的 repo.
git diff "@{yesterday}" #或者一个特定版本与倒数第二个变更之间：
git diff 1b6d "master~2" #输出结果都是补丁格式，可以用 git apply 来把补丁打上。也可以试一下：
git whatchanged --since="2 weeks ago" 

#其他操作#
git rm foobar #刪除
git mv old_file new_file #改檔名

#git log#
git log #可以查看当前git日志，以及hash值,查看之后
git reset --hard 7eff #只输入hash值前几个值就可以返回去


6）回滚
git reset HEAD filename #會從 staging area 狀態回到 unstaging 或 untracked (檔案內容並不會改變)
git checkout filename #會從 unstaging 狀態回到最初 repo. 的檔案(檔案內容變回修改前)

#!! 恢复git rm 的文件
先 git reset HEAD filename
然后观察 git status 里面的delete
在git checkout filename

7）不许要跟踪的文件
.gitignore，這個檔案可以編輯列出哪些檔案是要忽略不需要 tracked 的，像 Rails 就會加入 log/*.log 和 tmp/**/* 。
#可以修改全局的忽略文件#
git config --global core.excludesfile ~/.gitignore
语法："#"用于注释, !用于取反,/结尾当作文件夹/
也可以在当前文件指定

8）branch
git branch <new_branch_name> #建立本地 local branch
git branch -m <old_name> <new_name> #改名字 (如果有同名會失敗，改用 -M 可以強制覆蓋)
git branch #列出目前有那些 branch 以及目前在那個 branch
git checkout <branch_name> #切換 branch (注意到如果你有檔案修改了卻還沒 commit，會不能切換 branch，解法稍後會談)
git checkout -b <new_branch_name> (<from_branch_name>) #本地建立 branch 並立即 checkout 切換過去
git branch -d <branch_name> #刪除 local branch，如果要刪除的 branch 還沒有合併，就會有錯誤訊息。如果真的要強制刪除可以用 -D
git branch -r #列出远端分支

#merge#
git merge <branch_name> #合併另一個 branch，若沒有 conflict 衝突會直接 commit。若需要解決衝突則會再多一個 commit。
git merge --squash <branch_name> #將另一個 branch 的 commit 合併為一筆，特別適合需要做實驗的 fixes bug 或 new feature，最後只留結果。合併完不會幫你先 commit。
git cherry-pick 321d76f #只合併特定其中一個 commit。如果要合併多個，可以加上 -n 指令就不會先幫你 commit，這樣可以多 pick幾個要合併的 commit，最後再 git commit 即可。

#revert#
git revert 版本号 #令本地代码还原至xx版本号

#如果要換 branch 的暫時的解決方式是使用 git stash 會先把修改暫存下來，要回復則執行 git stash pop
这个在要保存不commit的修改时，还要切换分支合并分支什么的特别有用
git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。
git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。
git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。

git stash list 找到你要保存的栈时，例如是1
git stash apply stash@{1} 就是拿回1

9）远程库操作 remote Repo
首先要認識的是 Protocol，像在 Github 上面看自己的 Project，會有分 Public Clone URL 跟 Your Clone URL，這有什麼差?
  git://github.com/ihower/project.git #這種的是使用 Git 自己的 prototol，優點是速度快，但是沒有認證機制，只適合 read only (port:9418)
  git@github.com/ihower/project.git #這種的是使用 SSH，可以有認證(SSH key)
  #.Git 也可以透過 HTTPS 的方式，不過速度較慢，比較適合對 firewall 有限制的情況

#使用#
git clone <remote_address> 
git checkout --track -b foobar origin/foobar # 將遠端的 branch checkout 回來並建立一個新的 local branch，加上 --track 表示你之後還要pull、push回去，所以請 Git 記住對應關係。
git pull (<local_branch_name> origin/<remote_branch_name>) #去遠端 fetch 新版並 merge 進 local branch
git push #將 local branch 的 commit 紀錄更新到遠端
#git push 預設的遠端是 origin，並且會將所有有和 remote 有對應的 local branch 都 push 上去。如果要把新的 local branch push 上去，需要下 git push origin <local_branch_name> 指令。

#其他#
git fetch #把遠端的 branch 更新下載回來，但不會 merge 到 local branch
git branch -r #顯示 local 有追蹤的遠端 branch。注意到你不能直接修改這個 remote branch，一定要用一個 local branch 對應它。
git remote show origin #顯示遠端 server 的 branch
git remote add foobar git:// #可以新增別的 repo. 位置，於是 pull 的時候就可以指定要從哪一個遠端更新回來。
git push origin :foobar #刪除遠端的 branch

#github官方例子#
Global setup:
  git config --global user.name "JAS"
  git config --global user.email reducm@gmail.com
      
Next steps:
  mkdir
  cd StudyNotes
  git init
  touch README
  git add README
  git commit -m 'first commit'
  git remote add origin git@github.com:reducm/StudyNotes.git
  git push -u origin master
      
Existing Git Repo?
  cd existing_git_repo
  git remote add origin git@github.com:reducm/StudyNotes.git
  git push -u origin master

#在github 当你fork人创建自己的分支时，别人的分支更新后用这种方式pull别人的更新
git fetch upstream
git merge upstream/master

10）commit后  push前做的事！
還沒 push 前可以做的壞事，也就是 reset 跟 rebase。

#相較於 SVN 這種 commit 就是送到遠端伺服器，Git 的 commit 其實東西都還是在本地端，所以只要你還沒 push 出去分享給別人，你的 commit logs 是可以修改的!! 這種功能非常的 powerful，可以讓你 undo 和 rewrite commit history。如果你用 Git 只會 git commit 然後接著馬上 git push，那你就沒有學到精隨啊!~

#使用告誡：如果你已經 push 出去了，請千萬不要做 rewrite history 的動作，會天下大亂啊。正確善用 undo changes/rewrite history 的功能，我們可以讓東西準備好弄的整整齊齊才 push 出去給別人 pull。

#reset#
git reset #砍掉 commit 重來，但是修改的程式還是留在 working tree。
git reset HEAD^ #就會回到前一版本(一個^表示是前一版)，並把其中的 changes 繼續留在 working tree 中。適合發現前一次 commit 有問題或是想要修改 commit log，可以修改後再重新 commit。
git reset --soft HEAD^ #如果加上 –soft 參數則會把 changes 直接加到 staging area。
git reset --hard HEAD^ #加上 –hard 參數表示不留 staging area 也不留 working tree(完全刪除任何修改記錄)，則會完全抹掉前一次的 commit。
git reset HEAD filename #常用！把档案从staging移走(但還是留在working tree)
!!
git reset到上一版本HEAD^，会把HEAD的东西清掉，所以如果只想回到历史查看，最好使用git checkout (log md5)

通常soft的用法例如HEAD commit不满意,那么:
git reset --soft HEAD^ #把commit回归到上一版本，这时只会修改index staging area,不会修改working tree
xxxx操作 #
git commit -a -m "new" #修改好做个新的commit


11）分支结构推荐
主要分支
master: 永遠處在 production-ready 狀態
develop: 最新的下次發佈開發狀態
支援性分支
Feature branches: 開發新功能都從 develop 分支出來，完成後 merge 回 develop
Release branches: 準備要 release 的版本，只修 bugs。從 develop 分支出來，完成後 merge 回 master 和 develop
Hotfix branches: 等不及 release 版本就必須馬上修 master 趕上線的情況。會從 master 分支出來，完成後 merge 回 master 和 develop


12）push到github
git remote add origin git@github.com:username/Hello-World.git #Sets the origin for the Hello-World repo
git push origin master

13) 删除远端的分支,例如要删除 develop的分支
git push origin :develop #加一个冒号，如果出错，说明guthub上develop是当前主分支，切换到master就行

14) 发布本地的源码
git archive --format=tar --prefix=proj-1.2.3/ HEAD #打包成tar

15)git 恢复删除的文件
git 从使用的角度来说，的确没有svn方便
svn直接update即可恢复，但git pull却显示already up-to-date
要查看删除的文件： 
git ls-files –deleted
恢复则需要从新checkout：
git checkout – <deleted_file>
多个文件同时操作可以使用xargs
git ls-fies -d | xargs git checkout --

16)git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --"

用完上面这个命令之后，使用git lg 就能输出漂亮的git log

17)使用tig获得更漂亮的log输出
sudo apt-get install tig
然后在有git的项目目录下运行 tig #原理是使用 git log -p

18)github-fork!
例:
先到github fork ruby-china
然后把fork出来的pull到本地
本地再git remote add rubychina https://xxx.git #增加一个remote可以随时把这个remote的更新checkout到自己fork的线上 git pull rubychina (分支)

19).gitconfig文件的一些其他应用
[core]
    editor = vim
[alias]
    ci = commit -a -v
    throw = reset --hard HEAD
    throw = reset --hard HEAD^

20)git rebase
如果两人共同使用github,每次更新本地库都用简单的git pull的话，很容易会产生出不干净的历史（默认会加一条merge log）,比较好的做法是
git fetch
git rebase origin/master #举例假设是从远端的master带过来的
git push #这样log能保持干干净净

21)git show
git show HEAD:app/views/root/index.html.erb #直接查看历史版本的某个文件，head可以换成任意一个commit的md5

22)git blame
git blame routes.rb 详细查看哪个用户改了哪一行，针对单个文件


----------------------------------
自定义rails generate !!
首先
rails generate generator Initializer
便会产生这些东西
create  lib/generators/initializer
create  lib/generators/initializer/initializer_generator.rb
create  lib/generators/initializer/USAGE
create  lib/generators/initializer/templates
----------------------------------
关闭掉犯人的webtrick warn信息:
~/rvm/rubies/ruby-1.9.3-p0/lib/ruby/1.9.1/webrick/httpresponse.rb
.../ruby-1.9.3-p0/lib/ruby/1.9.1/webrick/httpresponse.rb
找到这个文件把第205行左右的位置注释掉
@logger.warn(msg)

----------------------------------
扩充ActiveRecord::Base
rails3里先在 application.rb 里加入 config.autoload_paths += %w( #{config.root}/lib/你的目录 )
然后
require '你的目录/文件'
再想在扩充类里面加入
ActiveRecord::Base.send(:include, MyPlugin) 
MyPlugin为定义在lib里面的module

----------------------------------
vim 创建rails的ctags
有些时候即时 bundle package 后 vendor/cache下面已经有了gem文件后
ctags -R 仍然不能生成带gem函数的tags
可以先在项目目录下运行一次 ctags -R
然后: ctags -aR `bundle show rails`/../*

---------------------------------
方便打开gem 文件源代码
先在bashrc文件加入
export EDITOR='gvim -f'
然后进入项目bundle open gemfile 

------------------------------------
在Rails里有三种加载源码的方式：

1.使用 require ，这个是ruby的方式。

2.基于 AcitiveSupport 的 const_missing 机制。如果找不到某个常量（类 或者 模块），就会根据其名称，去加载对应的文件，同时添加到一个已经加载的常量的列表里。比如在代码里使用了 Abc::Def，那么 Rails 就会尝试加载 abc/def.rb 这个文件。文件的搜索路径在 ActiveSupport::Dependencies.autoload_paths 中，可以在 application.rb 中用 config.autoload_paths 中添加。Rails-3 默认没有 'lib' 目录哦。所以默认情况下，使用这种方式加载不了。

3.使用 require_dependency 加载。
（load 也算一种，但似乎很少用）

使用第一种方式，应用启动后，只加载一次。使用后两种，在development 模式下，每次处理新的请求，都会重新加载。

但是要注意，后两种加载的时候，会把源码所在的文件展开为绝对路径，再去 require 。所以，使用Ruby-1.8.7 的时候要注意了：对于同一个文件，使用不同路径 require文件，Ruby-1.8.7 会加载多次。所以项目中应该统一使用一种方式加载。

另外：如果想让 ActiveSupport::Dependencies.autoload_paths 中的某个目录的子目录只加载一次，可以添加到 config.autoload_once_paths 中。

-----------------------------------
rails console 技巧from 37signals
用app这个对象的一些方便工具
1）查看路由出来的url
app.topics_path, app.topics_path(1)
2) 用helper调用helper方法
helper.link_to(xxxx)
3) 用source_location查看方法在哪里定义的
Topic.instance_methods(:destroy_all).source_location
----------------------------------
开发模式比webrick更快的服务器
gem 'thin' 
rails s thin
----------------------------------
use Full Text Search in PostgreSQL
rails g resource article body:text
in Migrate:
def change
    create_table :articles do |t|
	t.text :body
	t.column :search, 'tsvector' #重要，靠这个字段建索引

	t.timestamps
    end
end

execute <<-End_SQL
    CREATE INDEX articles_search_index
    ON articles USING gin(search)

    CREATE TRIGGER articles_search_update
    BEFORE INSEAR OR UPDATE ON articles
    FOR EACH ROW EXECUTE PROCEDURE
	tsvector_update_trigger (
	    search,
	    'pg_catalog.english',
	    body
	);
End_SQL
###上面的第二行gin是PostgreSQL全文搜索的关键
using in model:
class Article < ActiveRecord::Base
    def self.search(query)
	sql = sanitize_sql_array(["plainto_tsquery('english', ?)",query])
	where("search @@ #{sql}").order("ts_rank_cd(search, #{sql}) DESC")
    end
end


------------------------------------------
#!!! 错误处理页面
1)把routes加入exception处理
config.exceptions_app = routes
2)在routes.rb加
match "/404", to: 'errors#not_found'

#!!! 在controller里面使用view 的helper方法
比较牛X，使用view_context对象，顾名思义，这个是view环境上下文
in controller:
    view_context.link_to "a", article_path()

---------------------------------------
在model里面使用route_helper, 
Rails.application.routes.url_helpers.posts_path
Rails.application.routes.url_helpers.posts_url(:host => "example.com")

---------------------------------------
sprite-factory 使用 还有rmagick
gem rmagick除了重新编译imageMagick外，还可以下面这种快速安装方法
$ sudo aptitude install imageMagick libMagickWand-dev
$ sudo gem install rmagick
gem instal chunky_png

mac 下面用brew快速安装rmagick
sudo brew install ghostscript
sudo brew install imagemagick
#上面这一步如果little-cms有问题的话，就做下面这几步
sudo brew edit little-cms
replace
url 'http://www.littlecms.com/lcms-1.19.tar.gz'
with
url 'http://www.imagemagick.org/download/delegates/lcms-1.19.tar.gz' #(or an URL where you could find “lcms-1.19.tar.gz”)
sudo gem install rmagick

apt-get install imagemagick后
找不到Magick-config的话, 用
sudo apt-get install libmagick9-dev libmagicwand-dev

Can't' find MagickWand.h.的话
sudo apt-get install libmagickwand-dev


--------------------------------------
表单form_tag check_box_tag
form_tag(url_for_options = {}, options = {}, &block)
check_box_tag(name, value = "1", checked = false, options = {})
submit_tag(value = "Save changes", options = {})
select_tag(name, option_tags = nil, options = {})
hidden_field_tag(name, value = nil, options = {})

<%= form_tag xxx_path, :remote => true, :id => "add_write_off" do %> 
    <%= submit_tag "Write off", :id => "set_write_off" %><br/>
    <%= text_area_tag 'comment', nil, :size => "100x5", :id => "write_off_comment" %> 
<% end %>

--------------------------------------
rack 
rack是一种接口API，作用是解藕web server和web framwork,时web framwork可以随便轻松换web server
实现web很简单，只要一个对象，写他的call函数,扔入env(请求参数),返回一个数组["状态码","content type/或跳转的地址","内容"]就实现了rack,下面实现简单两个rack app例子：
用rackup方式:
Simpletest = proc {|env|["200",{"Content-Type" => "text/plain"}, ["ok"]]}# 因为ruby proc里面自己就有call方法
run Simpletest
命令行: rackup 这个文件

用ruby启动方式
require 'rack'
class Redirect
    def self.call(env)
	if env["QUERY_STRING"] =~ /method=redirect/
	    ["302",{"location" => "http://www.gu-da.com"}, []]
	else
	    ["200",{"Content-Type" => "text/plain"}, ["ok"]]
	end
    end
end

Rack::Server.new(:app => Redirect).start
用ruby跑一下这个文件,加段参数?method=redirect就会跳到域名

#rack middleware
是一个拦截器,可以组成middleware chain,可以处理添加一些常用功能特性
rack本来自己带了很多模组例如static阿request阿response阿之类的方便功能,用上面的例子添加一个Middleware:
Rack::Server.new(
    :app => Rack::Static.new(Ridriect, :urls => ["/assets"], :root => 'public', :index => 'index.html') 
).start #使用了Static模块先过滤了一下assets目录，然后在执行上面的Redirect的rack app

#使用Rack的Request和Response模组重写一下上面的redirect
class Redirect
    def self.call(env)
	request = Rack::Request.new(env)
	response = Rack::Response.new("ok")
	response.redirect("http://www.gu-da.com") if request.params["method"]=="redirect"
	response
    end
end
Rack::Server.new(app:Redirect).start

#把目录共享出去
run Rack::Directory.new("~/") #rackup this.ru

#在rails中添加middleware
class STH < Rails::Railtie
    config.app_middleware.use Redirect
end

--------------------------------------
railtie rails的核心，提供了一些钩子方法，让你扩展和修改rails的启动流程
class Railtie只有一个实例,还可以添加rake任务和generator

用回上面的例子
class STH < Rails::Railtie
    config.app_middleware.use Redirect #继承了Railtie之后可以访问这个config对象，他包含的配置是被所有railties和rails application共享的

    initializer "STH FIRST" do
	p "1"
    end

    initializer "STH SECOND", :before => "STH FIRST" do #注意这里是before first,所以会先p出2
	p "2"
    end
end

--------------------------------------
engine
class Engine < Railtie


--------------------------------------
在rails中model很多属性方法在生成实例才动态生成,因此在类中使用alias会失效
rails提供alias_attribute :new_method, :old_method 的方法

------------------------------------
capistrano
Capfile:
role :libs, "www.gu-da.com"
set :user, "root"

task :test_cap do
  run 'ls -l'
end

运行cap test_cap就可以到远端执行 ls -l的命令
除了把脚本写到capfile,也支持简单执行单行命令
cap invoke COMMAND="echo 'Hello World'" SUDO=1

经过一番实践，发现增加了不少复杂度
共享的东西都放在shared目录里面，包括carrierwave 的 public/uploads目录, 还有要注意各种assets问题

------------------------------------
rake 中处理大量数据库(mysql)时候的一些注意问题和推荐的方法
拿把redis东西存入mysql来说,参看自己gu-da项目的jcounter
直接使用ActiveRecord的话会有创建对象还要跑完多个callback/validation的问题，因此最好用native sql(嫌写sql麻烦可以使用http://sequel.rubyforge.org/ --sequel)
#以下内容都参考xdite的blog: http://blog.xdite.net/posts/2012/08/22/rails-with-massive-data/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+xxddite+%28Blog.XDite.net%29

#多用update_all, 少用each
避免:
posts = Post.where(:board_id => 5)
post.each do |post|
  post.board_id = 1
  post.save
end

使用
Post.update_all({:board_id => 1}, {:board_id => 5})

#多笔sql记录时，使用find_in_batchs
Post.find_in_batches(:conditions => "board_id = 5", :batch_size => 1000) do |posts|
  posts.each do |post|
    post.board_id = 1
    post.save
  end
end
#batch_size可以设置一次获取一笔多少条，默认是2000

#rails每笔都会单独一个transaction, 尽量一次transaction搞定
Post.find_in_batches(:conditions => "board_id = 5", :batch_size => 1000) do |posts|
  Post.transaction do
    posts.each do |post|
      post.board_id = 1
      post.save
    end
  end
end

#使用update_volumn,而不是save,因为save要跑完n多hooks
posts.each do |post|
  post.update_column(:board, 1)
  post.save
end
但 update_column 的缺點是一次只能 update 一個欄位，如果你有 update 多個欄位的需求，可以用sneacky-save 這套 gem。

#!!使用rails内置接口delegate,直接把多内容的column扔去令一个表

#记得打index

#delete 和 destroy代价昂贵，因为删操作的时候其实还要更新(update_index)表
注意destroy要跑完callback,而delete不用, delete_all和destroy_all也同样

#清空db的时候不要使用delete_all,用mysql的truncate table
ActiveRecord::Base.connection.execute("TRUNCATE TABLE #{table_name}")

#删除真的很慢，可以通过两个方法去“模拟”删除
1）加个标记软删除，并不是删除，只是标记这个东西已删除
2)开个新表，把要删的东西insert过去，insert比delete块很多

#这条来自ruby-china
有时候单要model的某一个值的时候，可以用pluck，返回的不是model,就只是一个值
Post.all.map(&:id)
# vs
Post.pluck(:id)
$ User.uniq.pluck(:email)
(0.2ms) SELECT DISTINCT email FROM "users"
=> ["james@example.com", "dana@example.com", "summer@example.com"]

---------------------
!!在rails直接获取mysql链接!
r = ActiveRecord::Base.connection.execute("select * from articles ")
r.each do |row|
    dosth with row
end

r.to_a 直接获取结果的数组

------------------
追加rails技巧，来源 http://ruby-china.org/topics/5289
1)在rails 项目添加todo功能！to-do
class UsersController < ApplicationController
  # TODO:  Make it possible to create new users.
end

class User < ActiveRecord::Base
  # FIXME: Should token really  be accessible?
  attr_accessible :bil, :email, :name, :token
end

然后用rake notes查看，也可以指定只看todo ==> rake notes:todo

2)用rails generate的时候，就给migration添加索引
rails g resource user name:index email:uniq token:string{6} bio:text
生成的migrate,会给name,email打上index，并且email要唯一:
class CreateUsers < ActiveRecord::Migration
  def change
    create_table :users do |t|
      t.string :name
      t.string :email
      t.string :token, :limit => 6
      t.text :bio
      t.timestamps
    end

    add_index :users, :name
    add_index :users, :email, :unique => true
  end
end

3)生成model的时候就指定关联关系，并自动打上index
rails g resource article user:references subject body:text
class CreateArticles < ActiveRecord::Migration
  def change
    create_table :articles do |t|
      t.references :user
      t.string :subject
      t.text :body
      t.timestamps
    end
    add_index :articles, :user_id
  end
end

class Article < ActiveRecord::Base
  belongs_to :user
  attr_accessible :body, :subject
end

4)覆盖关联关系
class Car < ActiveRecord::Base
  belongs_to :owner
  belongs_to :previous_owner, class_name: "Owner"

  def owner=(new_owner)
    self.previous_owner = owner
    super
  end
end
car更改 owner 时，如果有了 new_owner，就把原 owner 赋给 previous_owner，注意要加上 super

5)instantiate 假数据
Catagory.instantiate(id:0,name:"默认分类"),这样可以作个假分类，不会存到数据库

6)自动写文件，rails扩充了一下File的API
class Comment < ActiveRecord::Base
  # ...
  Q_DIR = (Rails.root + "comment_queue").tap(&:mkpath)
  after_save :queue_comment
  def queue_comment
    File.atomic_write(Q_DIR + "#{id}.txt") do |f|
      f.puts "Article: #{article.subject}"
      f.puts "User:    #{user.name}"
      f.puts body
    end
  end
end

7)合并相同key的hash, 主要用deep_merge
$ rails c
>> {nested: {one: 1}}.merge(nested: {two: 2})
#=> {:nested=>{:two=>2}}
>> {nested: {one: 1}}.deep_merge(nested: {two: 2})
#=> {:nested=>{:one=>1, :two=>2}}

8)hash的except，取反
$ rails c
>> params = {controller: "home", action: "index", from: "Google"}
#=> {:controller=>"home", :action=>"index", :from=>"Google"}
>> params.except(:controller, :action)
#=> {:from=>"Google"}

10)之前的关于自定义exception出错页面的方法，这里再详细写下
class Application < Rails::Applicationc 
# 设置
  config.exceptions_app = routes
end
路由里头:
match "/404", :to => "errors#not_found"

想在development环境下也可以读（开发环境默认是给debug信息）:
set config.consider_all_requests_local to false in your config/environments/development.rb

----------------------
Rails 发邮件
rails g mailer CommentMailer #如此会在app/mailers下面生成一个comment_mailer.rb的文件
打开文件： 第一行
default from: "from@example.com" #发送邮件的邮箱地址
在mailer里面的每一个方法都是针对不通种类的邮件，例如可以有评论后提醒用户，或者通知订阅者有最新文章
def comment_notify_email(comment)
  @comment = Comment.find(comment) #这里的实例变量在mail_view里面也可以引用到
  @url = post_url(@comment.post)
  mail to:@comment.post.user.email, subject:'有新回复'
end

然后在app/views/comment_mailer/ 创建一个comment_notify_email.html.erb和comment_notify_email.text.erb作为视图
打开配置:
env/environments/develoment.rb
config.action_mailer.delivery_method = :smtp #还有server或者file
config.action_mailer.smtp_settings = {
  address:"smtp.gmail.com",
  port:507,
  username:"jas",
  password:"hello",
  authentication:'plain',
  enable_starttls_auto:true
}
发送:
CommentMailer.comment_notify_email(Comment.last).deliver


----------------------
Rails4.0新特性

Ruby 1.9.3 only
Strong Parameters
Queue API
Caching Improvements
https://github.com/rails/rails/commits/master
https://github.com/rails/rails/blob/master/guides/source/4_0_release_notes.md

20日添加
1)Add /rails/info/routes path 把之前rake routes的内容放进来，可以更快得到routes的信息
2) Rails.application.config.console= 
  # it can be added to config/application.rb
console do
# this block is called only when running console,
# so we can safely require pry here
  require "pry"
  config.console = Pry
end
  


之前
1)ActiveSupport::Queue #用于后台队列新线程处理一些不用即时返回结果 或 昂贵代价（一般会容易令链接阻塞）的操作
class ExpenceOperation
  def run #实现一个run方法就行
    #...
  end
end
Rails.queue.new(ExpenceOperation.new) #what ever you want
config.queue = ActiveSupport::Queue
config.queue_consumer = ThirdPart::Stuff

2)Async ActionMailer #同上，可以后台任务发邮件
在mailer的class里面
self.async = true

3)strong_parameter # mass assignment protection in controller
model将不用再写 attr_accessible, 参数可以直接在controller里面切走不安全的
class PostController
  def create
    Post.create(post_params)
  end

  private
  def post_params
    params.require(:post).
      permit(:title, :body)
  end
end
nested permit
params.permit(:name, { emails: []  },
	       friends: [ :name,
	     { family: [ :name  ], hobbies: []  }])
a.再设过strong_parameter的controller里,以后如果直接把params这东西扔给 mass-assigned model的话会直接raise ForbiddenAttributesError
b.但m-a model用在其他地方也会可以接收到params
c.attr_acessiable 和 attr_protected 会被移除, 放到protected_attributes的 gem

d.在new的action里面可以用fetch,这样会用一个空对象
params.fetch(:blog, {}).permit(:title, :author)

e.可以用tap去定义scope之外的其他参数
def product_params
    params.require(:product).permit(:name).tap do |whitelisted|
      whitelisted[:data] = params[:product][:data]
    end
end

4) turbo_links pjax
可以通过turbolinks.js来做全站的ajax...

关闭turbolinks
Remove the gem 'turbolinks' line from your Gemfile.
Remove the //= require turbolinks from your app/assets/javascripts/application.js.
Remove the two "data-turbolinks-track" => true hash key/value pairs from your app/views/layouts/application.html.erb.
5)russian doll caching 缓存策略
旧的cache view的方式，设好memcache或redis后
<% cache ["v1", Catagory] do%>
  Catagory : <%= Catagory.name %>
<% end%>
旧方式有可能在多个render或者 model嵌套后， nested的内容更新不了,例如上面的 v1也可能会有冲突

rails4.0方式,粒度更少，帮你掌管好key，不用管太多其他东西:
<% cache Catagory do%>
  Catagory : <%= Catagory.name %>
<% end%>

之前的actionpack-page_caching actionpack-action_caching都废弃了，extra to gem

6)ActionController::Live #利用html5 websocket的实时stream!
class YourController
  include ActionController::Live
  def index
    100.times {
      response.stream.write "hello \n"
    }
    ensure
      response.stream.close 
  end
end

7)ActiveRecord
a. Relation#all returns a relation
Post.all.class #=> ActiveRecord::Relation 
现在 Model.all会返回一个relation_ship对象，用的时候才读库

b.scoped 废弃
Post.scoped #=>deprecation warning!

c.nil 不再抱怨
rails3
nil.id #=> RuntimeError blahblahblah...
rails4
nil.id #=> nomethod for nil class!

d. update_attribute|attributes 会改进 ？不再迷迷糊糊的要你记update_attribute其实是不跑validate的，update_column和columns又其实没有分别的...
是不是经常被 #update_attributes 和 #update_attribute 还有 #update_column 搞晕？好消息来了——Rails 4 重新整理了属性更新的方法，现在的方式简单明了：
@book.update(post_params) # 会触发验证
@book.update_columns(post_params) # 构建 SQL 语句，直接执行于数据库层，不会触发验证

e. first 和 last的sql语句改进了,性能改进

8) 框架的其他新特性
a. plugins 死刑，不再支持,建议旧的plugin移到lib，然后在initializer里面require

b. Rails2 的find接口死刑
User.find(:all)
User.find(:first) 之类的
Post.find(:all, :conditions => { :comments_count => 10  }, :limit => 5) | use this Post.where(comments_count: 10).limit(5)

c.之前一对多，找一然后关联多 并以多的那一方做条件，会产生sql outer join, 这个也废弃
Post.includes(:comments).where("comments.id > ?", ...)  这一类
Rails 4的做法，应该更详细指定条件
Post.includes(:comments).where("comments.id > ?", ...).references(:comments)  不懂
Post.includes(:comments).where(:comments=>{title:""...})
Post.includes(:comments).order("commments.created_at")

d. 一些find_by的方法会被取代, 用后面的东西取代
find_by        | ok
find_all_by    | where()
scoped_by      | where()
find_last_by   | where().last
find_or_create | where().first_or_create
find_or_initialize_by | wehere().first_or_initialize

现在的where和find_by都很强大，有点向mongoid的方向靠
推荐
Book.where(author: 'Albert Yu')

Book.find_all_by_title('Rails 4') # rails3 way
Book.find_last_by_author('Albert Yu') # rails3 way

Book.where(title: 'Rails 4') # rails4 way
Book.where(author: 'Albert Yu').last # rails4 way

find_by 很像mongoid了
Book.find_by_title('Rails 4') # 接收单个参数的用法在 r3 & r4 都可以
Book.find_by(title: 'Rails4') # 不过 r4 更偏爱这样写
Book.find_by_title('Rails 4', conditions: { author: 'Albert Yu'  }) # 这就不好了，得改
Book.find_by(title: 'Rails4', author: 'Albert Yu') # Wow! 太棒了！
统一使用 find_by 不仅有更好的一致性，而且更便于接收 hash 参数：
book_param = { title: 'Rails 4', author: 'Albert Yu'  }
Book.find_by(book_param)

find_by 方法的内部实现其实很简单：
# activerecord/lib/active_record/relation/finder_methods.rb
def find_by(*args)
  where(*args).take
end

找或更新
Book.find_or_initialize_by(title: 'Rails 4')
Book.find_or_create_by(title: 'Rails 4')

e. 推荐使用scope 都用lambda
scope :recent, lambda{ |date| where(["created_at > ? ", date ]) } 
scope :red, where(color: 'red')
default_scope where(color: 'red')
Use this:
scope :red, -> { where(color: 'red')  }
default_scope { where(color: 'red')  }

f. ajax form_for 里:remote=>true auth_token的问题
remote:true自然没问题，rails4好像javascript要提交数据的话要手动指定authenticity_token了
手动加csrf的方法
$.ajax({ 
  url: 'YOUR URL HERE',
  type: 'POST',
  beforeSend: function(xhr) {xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'))},
  data: 'someData=' + someData,
  success: function(response) {
      $('#someDiv').html(response);
  }
});

i.Remove Rack::SSL in favour of ActionDispatch::SSL

以上移除的东西，4.0会提示deprecate,4.1全部只能用gem，5.0会直接不支持

j.路由变化 routes
过去
resources :messages do
  resources :comments
  resources :categories
  resources :tags
end

resources :posts do
  resources :comments
  resources :categories
  resources :tags
end

resources :articles do
  resources :comments
  resources :categories
  resources :tags
end

现在可以用concern重构，重新组织一下
concern :sociable do
  resources :comments
  resources :categories
  resources :tags
end

resources :messages, concerns: :sociable
resources :posts, concerns: :sociable
resources :articles, concerns: :sociable
可以传参数
concern :sociable do |options|
  resources :comments, options
  resources :categories, options
  resources :tags, options
end

resources :messages, concerns: :sociable
resources :posts, concerns: :sociable
resources :articles do
  concerns :sociable, only: :create
end

抽出来成为单独类
# app/concerns/sociable.rb
class Sociable
  def self.call(mapper, options)
    mapper.resources :comments, options
    mapper.resources :categories, options
    mapper.resources :tags, options
  end
end

# config/routes.rb
concern :sociable, Sociable

resources :messages, concerns: :sociable
resources :posts, concerns: :sociable
resources :articles do
  concerns :sociable, only: :create
end
---------------------------------------------------
Sprockets: Rack-based asset packaging
这东西就是rails用于管理assets的东西,用这个全局变量去做各种操作Sprockets::Environment, rails里面已经把这变量设成Your::Application.assets,并做了各种设置, 我们可以用这变量去做些操作，例如添加其他位置的assets，或者除了 coffee 之外加入更多javascript的编译器，例如老赵的wind.js
gem 'sprockets', '~> 2.0'
基础添加assets设置可以做这些操作: append or prepend _path
environment = Sprockets::Environment.new
environment.append_path 'app/assets/javascripts'
environment.append_path 'lib/assets/javascripts'
environment.append_path 'vendor/assets/jquery'

在rails里，获取了environment变量后，可以这样拿到你各个assets的Sprockets变量
例如 environment['application.js'], 用to_s方法可以得到处理后的js文件结果, pathname方法可以拿到文件的绝对路径
environment还有以下几种搞法，
拿到tilt引擎
environment.engines #=>
#{".coffee"=>Tilt::CoffeeScriptTemplate,
 #".jst"=>Sprockets::JstProcessor,
 #".eco"=>Sprockets::EcoTemplate,
 #".ejs"=>Sprockets::EjsTemplate,
 #".less"=>Tilt::LessTemplate,
 #".sass"=>Sass::Rails::SassTemplate,
 #".scss"=>Sass::Rails::ScssTemplate,
 #".erb"=>Tilt::ERBTemplate,
 #".str"=>Tilt::StringTemplate}
假如 tilt = environment.engines[".coffee"] #拿到引擎后可以：
tilt.new("xxx.js.coffee").render #=> 输出这个文件用coffee编译过后的js结果

支持各种方便搞assets的gem
.js.coffee .css.sass(or scss) .css.less 

#!!!
不得不题的是sprockets支持两个很好的JS Template
.jst 文件是指明这文件是js模板，当被加载的时候，传进来的局部变量都位于 JST这个命名空间Object下, 这东西会调用一个模板方法把jst文件都转成可以插到Dom里面的string:
<!-- templates/hello.jst.ejs -->
<div>Hello, <span><%= name %></span>!</div>

// application.js
//= require templates/hello
$("#hello").html(JST["templates/hello"]({ name: "Sam"  }));  #这里可以用hello的模板，然后把 name:"Sam"传过去

Sprockets 支持 ejs(里面嵌javascript), eco(里面嵌CoffeeScript), 这两种语言的嵌入都是和ruby一样用<% ..%>  or <%= %>, 另外还有大名顶顶的erb

father: eco repository https://github.com/sstephenson/eco
	ruby-eco https://github.com/sstephenson/ruby-eco
#!!
其实Sprockets 支持多种引擎嵌套，例如你想先用Coffee,再用erb，你可以把文件改名成 .js.coffee.erb, 在erb里跑ruby代码的context是Sprockets::Context

Sprockets里assets加载其他模块代码的方式
写在文件最开头用语言的注释 + =号的方式表明加载哪些代码
//= require jquery
//= require jquery-ui
//= require backbone
//= require_tree .
还有这几种加载方式
/* Multi-line comment blocks (CSS, SCSS, JavaScript)
 *= require foo
*/

// Single-line comment blocks (SCSS, JavaScript)
//= require foo

# Single-line comment blocks (CoffeeScript)
#= require foo

各种加载方法区别:
require 就算后面require同个文件，只会require一次
include 和require差不多，但是同个文件会require多次
require_directory 加载后面指定目录的所有文件，并按文件首字母顺序去加载
require_tree 也是指定加载目录，但是还会递归式地去加载子目录
require_self 意思是，后续所有的require include的文件里面都先把我这个source文件里的body先require一下,用于有时每个JS文件前都做些初始化的内容
stub 黑名单，后面的东西其他文件也不能require到

rails3的coffee里用eco的例子
假如你有这个eco模板
app/assets/javascripts/todos/views/todo.jst.eco
然后在coffee里面用JST这东西去require eco
JST['todos/views/todo']({model: somemodel}) #参考spine的用法，在后面的小括号传的参数可以在eco里面用 @model 去读取

<%= %> 这样有用sanitize, 会输出转义后的内容, 
<%- %> 这样才是直接嵌入到dom html #-
-----------
assets 更多自定义
定义压缩css和js引擎
config.assets.css_compressor = :yui
config.assets.js_compressor = :uglifier

自定义压缩引擎，创建一个自己的类，一定要带个compress方法就行
class Transformer
  def compress(string)
    do_something_returning_a_string(string)
  end
end
config.assets.css_compressor = Transformer.new


ngnix让assets缓存更长的配置
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;

  add_header ETag "";
  break;
}
assets precompile之后,还有gzip的版本.gz文件，让nginx支持gzip
location ~ ^/(assets)/  {
  root /path/to/public;
  gzip_static on; # to serve pre-gzipped version
  expires max;
  add_header Cache-Control public;
}

assets缓存方式，默认是交给sprockets管，可以自己定义
config.assets.cache_store = :memory_store, { :size => 32.megabytes  }

##!!
做自己的Pre-processor
要用一下这个 gem https://github.com/rtomayko/tilt, 主要是提供了一套interface让你处理web framwork里头各种模板塞在一起的问题,可以轻松的更换各种模板

#场景假设：例如我想遇到js.coffee.erb文件先用coffee编译好javascript，然后再在上面套一个js异步变同步的引擎，编译好后在用ruby处理erb模板

##
如果使用了rabl, 那么在view里面也可以继续用data-attributes去传文件给javascript
<div data-article="<%= render template: "article/articles.json.rabl" %>" ></div>

/##
rake 遇到no matches found: import_fontello[tmp/fontello-08685a8c.zip] 的时候时，是zsh错误
用 noglob rake 可以过

##
element.scrollIntoView()可以让element滚动到可视范围

##user_agent
request.env["HTTP_USER_AGENT"]


--------------------
counter_cache, 把要要统计数量的关联model缓存
class Blog < ActiveRecord::Base 
  has_many :comments 
end 

class Comment < ActiveRecord::Base 
  belongs_to :blog, :counter_cache => true 
end 
注意：  blogs中有一个字段是comments_count(整型)，当添加和删除comment的时候，会在它所对应的blogs中的comments_count加或减1，这里需要注意的是destroy和destroy_all,可以触发blogs中的comments_count加或减1，而delete和delete_all则不会。 

此外如果要指定特定的名字的话呢，就 :counter_cache => :pinlun_counts,这样在blogs中就使用pinlun_counts,而不是comments_count. 



-------------------------
缓存技巧, 
#304 Not Modified 客户端缓存
用fresh_when
class ArticlesController
  def show
    @article = Article.find(params[:id])
    fresh_when :last_modified => @article.updated_at.utc, :etag => @article
  end
end
下次用户再访问的时候，会对比request header里面的If-Modified-Since和If-None-Match，如果相符合，就直接返回304，而不再生成response body。

但是这样会遇到一个问题，假设我们的网站导航有用户信息，一个用户在未登陆专题访问了一下，然后登陆以后再访问，会发现页面上显示的还是未登陆状态。或者在app访问一篇文章，做了一下收藏，下次再进入这篇文章，还是显示未收藏状态。解决这个问题的方法很简单，将用户相关的变量也加入到etag的计算里面：

fresh_when :etag => [@article.cache_key, current_user.id]
fresh_when :etag => [@article.cache_key, current_user_favorited]
要注意nginx gzip的坑

Rails4的cache_action, 利用cache_path可以把一些类似分页的请求参数也缓存起来
class CategoriesController
  caches_action :index, :expires_in => 1.day, :cache_path => proc {"categories/index/#{params[:page].to_i}"}
end

例如对非登陆用户，缓存首页
class HomeController
  caches_action :index, :expires_in => 3.hours, :if => proc {!user_signed_in?}
end

1. 静态资源的缓存
rails Assets Pipeline，一定要开启！
# config/environments/production.rb
config.assets.digest = true


2、在 Nginx 里面将 CSS, JS, Image 的缓存有效期设成 max；
location ~ (/assets|/favicon.ico|/*.txt) {
  access_log        off;
  expires           max;
  gzip_static on;
}
/


-------
rails c tips
上一个命名的结果

执行完一条命令

Article.first
但其实你还想对这个返回的 article 对象继续操作。再执行一遍？

article = Article.first
NO！ 你可以用

article = _
"_"保存着上一条命令返回的结果

发起HttpRequest

>>app.get “/“
=> 200
>>app.get “/orders”
=> 302

Rails沙盒

console可以已沙盒的模式运行，

rails console --sandbox
>>User.destroy(1)
>>exit
(0.1ms) rollback transaction


#Rails4.1部署坑
用capistrano2部署时找不到manifest的话，去shared/assets下面创建个空文件 manifest.yml就行

记得有secrets.yml的话，rake secret一下把key更新上去


#Rails 4.2 新增后端任务框架 - Active Job
不同的延迟任务，一样的 API.

在 Delayed Job、Resque、Sidekiq 等延迟任务之间切换，还要改代码？
以后就不用了...

虽然这几个延迟任务 gem 使用上类似，但语法上多少有一点不同。
新的 Active Job 组件统一了接口，使用和切换都会变得更容易。

QueueAdapter

默认使用的 queue_adapter 是 :inline，你可以根据需要自己设置 queue_adapter.

已经支持 Delayed Job、Resque、Sidekiq 等常用延迟任务 gem.

# default queue adapter
ActiveJob::Base.queue_adapter = :inline

# Adapters currently supported: :backburner, :delayed_job,
# :qu, :que, :queue_classic, :resque, :sidekiq, :sneakers, :sucker_punch
QueueName

默认使用的 queue_name 是 "default"

可以定制：

 queue_as :my_jobs
Enqueuing 入队与重试

常用方法：

# Enqueue a job to be performed as soon the queueing system is free.
MyJob.enqueue record

# Enqueue a job to be performed tomorrow at noon.
MyJob.enqueue_at Date.tomorrow.noon, record

# Enqueue a job to be performed 1 week from now.
MyJob.enqueue_in 1.week, record
任务失败，还可以：

retry_now
retry_in
retry_at
Execution 执行

# 不是 perform、run、work
execute(job_id, *serialized_args)
Callbacks 回调

比某些延迟 gem 多做了一点点，除了队列&执行本身外，还可以有回调：

before_enqueue
around_enqueue
after_enqueue

before_perform
around_perform
after_perform
Logging

around_enqueue 和 around_perform 有日志记录

enqueue、enqueue_at、perform_start、perform 等过程也有日志记录

Identifier

每个任务都有全局唯一的 job_id

Others

有利必有弊，可能面临以下问题：
原 gem 本身的特点没能充分利用，灵活性降低，和其它 gem 的配合会变复杂。

源代码 Active Job -- Make work happen later
代码比较简洁、清晰，感兴趣的可以看看。

Rails4.1新特性

enum ActiveRecord column
class Conversation < ActiveRecord::Base
  enum status: [ :active, :archived  ]
end
 
conversation.archived!
conversation.active? # => false
conversation.status  # => "archived"
 
Conversation.archived # => Relation for all archived Conversations
 
Conversation.statuses # => { "active" => 0, "archived" => 1  }

#第二中描述
class Bug < ActiveRecord::Base
  # Relevant schema change looks like this:
  #
  # create_table :bugs do |t|
  #   t.column :status, :integer, default: 0 # defaults to the first value (i.e. :new)
  # end
  enum status: [ :new, :assigned, :in_progress, :resolved, :rejected, :reopened ]
  belongs_to :assignee, class_name: 'Developer'
  def assignee=(developer)
    if developer && self.new?
      self.status = :assigned
    else
      self.status = :new
    end

    super
  end
end

Bug.resolved           # => a scope to find all resolved bugs

bug.resolved?          # => check if bug has the status :resolved

bug.resolved!          # => update! the bug with status set to :resolved

bug.status             # => 4.2变成String a symbol describing the bug's status

bug.status = :resolved # => set the bug's status to :resolved

#注意的是用数组方式去注明status的话，以后不能修改他们的位置状态，因为会导致原有数据错乱，可以用下面的方法声明时指定他们的数据
class Bug < ActiveRecord::Base
  enum status: {
    new: 0,
    in_progress: 2,
    resolved: 3,
    rejected: 4,
    reopened: 5
  }
end

#不同状态不要用相同的symbol
class Bug < ActiveRecord::Base
  enum status: [ :new, ... ]
  enum code_review_status: [ :new, ... ] # WARNING: Don't do this!
end

#用scope查询的时候，要传真实的enum值，可以用enum常量去做
class Bug < ActiveRecord::Base
  scope :open, -> {
    where('status <> ? OR status <> ?', STATUS[:resolved], STATUS[:rejected])
  }
end

##4.2
#class Conversation < ActiveRecord::Base
#  enum status: [ :active, :archived  ]
#  end
#
#  # conversation.update! status: 0
#  conversation.active!
#  conversation.active? # => true
#  conversation.status  # => "active"
#
#  # conversation.update! status: 1
#  conversation.archived!
#  conversation.archived? # => true
#  conversation.status    # => "archived"
#
#  # conversation.update! status: 1
#  conversation.status = "archived"
#
#  # conversation.update! status: nil
#  conversation.status = nil
#  conversation.status.nil? # => true
#  conversation.status      # => nil
#


-------------------
Rails 使用postgresql
#in Gemfile: 
gem 'pg'

#in databases.yml:
default: &default
  adapter: postgresql
  encoding: unicode
  pool: 5

#Array数据类型
# db/migrate/20140207133952_create_books.rb
create_table :books do |t|
  t.string 'title'
  t.string 'tags', array: true
  t.integer 'ratings', array: true
end
add_index :books, :tags, using: 'gin'
add_index :books, :ratings, using: 'gin'


postgres migration里如果遇到change_column要把字符串转成数组,要这样写
change_column :movies, :aliases, "varchar[] USING (string_to_array(aliases, ','))", default: []

 
# app/models/book.rb
class Book < ActiveRecord::Base
end
 
# Usage
Book.create title: "Brave New World",
            tags: ["fantasy", "fiction"],
            ratings: [4, 5]
 
## Books for a single tag
Book.where("'fantasy' = ANY (tags)")
## Books for multiple tags
Book.where("tags @> ARRAY[?]::varchar[]", ["fantasy", "fiction"])
## Books with 3 or more ratings
Book.where("array_length(ratings, 1) >= 3")

#另一例子
create_table :categories do |t|
  t.string :name, null: false
end

create_table :products do |t|
  t.string :name, null: false
  t.references :category, null: false
  t.text :tags, array: true, default: []
end

然后开个db玩玩
$ rails db
> insert into products(name, category_id, tags) values('T-Shirt', 3, '{clothing, summer}');
> insert into products(name, category_id, tags) values('Sweater', 3, ARRAY['clothing', 'winter']);
> select * from products;
1  |  T-Shirt  |  3  | {clothing, summer}
2  |  Sweater  |  3  | {clothing, winter}

原生语句用 {xxx, xxx}, 或ARRAY['xxxx', 'xxxx']都可以

#Hstore 类似hash类型
# db/migrate/20131009135255_create_profiles.rb
ActiveRecord::Schema.define do
  create_table :profiles do |t|
    t.hstore 'settings'
  end
end
 
# app/models/profile.rb
class Profile < ActiveRecord::Base
end
 
# Usage
Profile.create(settings: { "color" => "blue", "resolution" => "800x600" })
 
profile = Profile.first
profile.settings # => {"color"=>"blue", "resolution"=>"800x600"}
 
profile.settings = {"color" => "yellow", "resolution" => "1280x1024"}
profile.save!
 
## you need to call _will_change! if you are editing the store in place
profile.settings["color"] = "green"
profile.settings_will_change!
profile.save!

#JSON类型
# db/migrate/20131220144913_create_events.rb
create_table :events do |t|
  t.json 'payload'
end
 
# app/models/event.rb
class Event < ActiveRecord::Base
end
 
# Usage
Event.create(payload: { kind: "user_renamed", change: ["jack", "john"]})
 
event = Event.first
event.payload # => {"kind"=>"user_renamed", "change"=>["jack", "john"]}
 
## Query based on JSON document
Event.where("payload->'kind' = ?", "user_renamed")


#Range 类型, 类似Ruby类型

# db/migrate/20130923065404_create_events.rb
create_table :events do |t|
  t.daterange 'duration'
end
 
# app/models/event.rb
class Event < ActiveRecord::Base
end
# Usage
Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))
 
event = Event.first
event.duration # => Tue, 11 Feb 2014...Thu, 13 Feb 2014
 
## All Events on a given date
Event.where("duration @> ?::date", Date.new(2014, 2, 12))
 
## Working with range bounds
event = Event.
  select("lower(duration) AS starts_at").
  select("upper(duration) AS ends_at").first
 
event.starts_at # => Tue, 11 Feb 2014
event.ends_at # => Thu, 13 Feb 2014

#UUID 类型, 类似monogo

要用uuid的插件
# db/migrate/20131220144913_create_devices.rb
enable_extension 'uuid-ossp' unless extension_enabled?('uuid-ossp')
create_table :devices, id: :uuid, default: 'uuid_generate_v4()' do |t|
  t.string :kind
end

#遇到postgres需要change_column 的migration时，要用特别的写法
  def up
    change_column :messages, :duration, 'integer USING CAST(duration AS integer)'
    remove_column :messages, :pic
  end

  def down
    change_column :messages, :duration, 'string USING CAST(duration AS string)'
    add_column :messages, :pic, :string
  end 

# app/models/device.rb
class Device < ActiveRecord::Base
end
 
# Usage
device = Device.create
device.id # => "814865cd-5a1d-4771-9306-4268f188fe9e"

#!!!! Rails 4.2的升级

1 升级至 Rails 4.2
如果您正试着升级现有的应用，应用最好要有足够的测试。第一步先升级至 4.1，确保应用仍正常工作，接着再升上 4.2。升级需要注意的事项在 Ruby on Rails 升级指南可以找到。

2 重要新特性
2.1 Active Job
Active Job 是 Rails 4.2 新搭载的框架。是队列系统（Queuing systems）的统一接口，用来连接像是 Resque、Delayed Job、Sidekiq 等队列系统。

采用 Active Job API 撰写的任务程序（Background jobs），便可在任何支持的队列系统上运行而无需对代码进行任何修改。Active Job 缺省会即时执行任务。

任务通常需要传入 Active Record 对象作为参数。Active Job 将传入的对象作为 URI（统一资源标识符），而不是直接对对象进行 marshal。新增的 GlobalID 函式库，给对象生成统一资源标识符，并使用该标识符来查找对象。现在因为内部使用了 Global ID，任务只要传入 Active Record 对象即可。

譬如，trashable 是一个 Active Record 对象，则下面这个任务无需做任何序列化，便可正常完成任务：

class TrashableCleanupJob < ActiveJob::Base
  def perform(trashable, depth)
    trashable.cleanup(depth)
  end
end
参考 Active Job 基础指南来进一步了解。

2.2 异步邮件
构造于 Active Job 之上，Action Mailer 新增了 #deliver_later 方法，通过队列来发送邮件，若开启了队列的异步特性，便不会拖慢控制器或模型的运行（缺省队列是即时执行任务）。

想直接发送信件仍可以使用 deliver_now。

2.3 Adequate Record
Adequate Record 是对 Active Record find 和 find_by 方法以及其它的关联查询方法所进行的一系列重构，查询速度最高提升到了两倍之多。

工作原理是在执行 Active Record 调用时，把 SQL 查询语句缓存起来。有了查询语句的缓存之后，同样的 SQL 查询就无需再次把调用转换成 SQL 语句。更多细节请参考 Aaron Patterson 的博文。

Adequate Record 已经合并到 Rails 里，所以不需要特别启用这个特性。多数的 find 和 find_by 调用和关联查询会自动使用 Adequate Record，比如：

Post.find(1)  # First call generates and cache the prepared statement
Post.find(2)  # Subsequent calls reuse the cached prepared statement
 
Post.find_by_title('first post')
Post.find_by_title('second post')
 
post.comments
post.comments(true)
有一点特别要说明的是，如上例所示，缓存的语句不会缓存传入的数值，只是缓存语句的模版而已。

下列场景则不会使用缓存：

当 model 有缺省作用域时
当 model 使用了单表继承时
当 find 查询一组 ID 时：
# not cached
Post.find(1, 2, 3)
Post.find([1,2])
以 SQL 片段执行 find_by：
Post.find_by('published_at < ?', 2.weeks.ago)
2.4 Web 终端
用 Rails 4.2 新产生的应用程序，缺省搭载了 Web 终端。Web 终端给错误页面添加了一个互动式 Ruby 终端，并提供视图帮助方法 console，以及一些控制器帮助方法。

错误页面的互动式的终端，让你可以在异常发生的地方执行代码。插入 console 视图帮助方法到任何页面，便可以在页面的上下文里，在页面渲染结束后启动一个互动式的终端。

最后，可以执行 rails console 来启动一个 VT100 终端。若需要建立或修改测试资料，可以直接从浏览器里执行。

2.5 外键支持
迁移 DSL 现在支持新增、移除外键，外键也会导出到 schema.rb。目前只有 mysql、mysql2 以及 postgresql 的适配器支持外键。

# add a foreign key to `articles.author_id` referencing `authors.id`
add_foreign_key :articles, :authors
 
# add a foreign key to `articles.author_id` referencing `users.lng_id`
add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
 
# remove the foreign key on `accounts.branch_id`
remove_foreign_key :accounts, :branches
 
# remove the foreign key on `accounts.owner_id`
remove_foreign_key :accounts, column: :owner_id
完整说明请参考 API 文档：add_foreign_key 和 remove_foreign_key。

3 Rails 4.2 向下不兼容的部份
前版弃用的特性已全数移除。请参考文后下列各 Rails 部件来了解 Rails 4.2 新弃用的特性有那些。

以下是升级至 Rails 4.2 所需要立即采取的行动。

3.1 render 字串参数
4.2 以前在 Controller action 调用 render "foo/bar" 时，效果等同于：render file: "foo/bar"；Rails 4.2 则改为 render template: "foo/bar"。如需 render 文件，请将代码改为 render file: "foo/bar"。

3.2 respond_with / class-level respond_to
respond_with 以及对应的类别层级 respond_to 被移到了 responders gem。要使用这个特性，把 gem 'responders', '~> 2.0' 加入到 Gemfile：

# app/controllers/users_controller.rb
 
class UsersController < ApplicationController
  respond_to :html, :json
 
  def show
    @user = User.find(params[:id])
    respond_with @user
  end
end
而实例层级的 respond_to 则不受影响：

# app/controllers/users_controller.rb
 
class UsersController < ApplicationController
  def show
    @user = User.find(params[:id])
    respond_to do |format|
      format.html
      format.json { render json: @user }
    end
  end
end
3.3 rails server 的缺省主机（host）变更
由于 Rack 的一项修正，rails server 现在缺省会监听 localhost 而不是 0.0.0.0。http://127.0.0.1:3000 和 http://localhost:3000 仍可以像先前一般使用。

但这项变更禁止了从其它机器访问 Rails 服务器（譬如开发环境位于虚拟环境里，而想要从宿主机器上访问），则需要用 rails server -b 0.0.0.0 来启动，才能像先前一样使用。

若是使用了 0.0.0.0，记得要把防火墙设置好，改成只有信任的机器才可以存取你的开发服务器。

3.4 HTML Sanitizer
HTML sanitizer 换成一个新的、更加安全的实现，基于 Loofah 和 Nokogiri。新的 Sanitizer 更安全，而 sanitization 更加强大与灵活。

有了新的 sanitization 算法之后，某些 pathological 输入的输出会和之前不太一样。

若真的需要使用旧的 sanitizer，可以把 rails-deprecated_sanitizer 加到 Gemfile，便会用旧的 sanitizer 取代掉新的。而因为这是自己选择性加入的 gem，所以并不会抛出弃用警告。

Rails 4.2 仍会维护 rails-deprecated_sanitizer，但 Rails 5.0 之后便不会再进行维护。

参考这篇文章来了解更多关于新的 sanitizer 的变更内容细节。

3.5 assert_select
assert_select 测试方法现在用 Nokogiri 改写了。

不再支援某些先前可用的选择器。若应用程式使用了以下的选择器，则会需要进行更新：

属性选择器的数值需要用双引号包起来。

a[href=/]      =>     a[href="/"]
a[href$=/]     =>     a[href$="/"]
含有错误嵌套的 HTML 所建出来的 DOM 可能会不一样

譬如：

# content: <div><i><p></i></div>
 
# before:
assert_select('div > i')  # => true
assert_select('div > p')  # => false
assert_select('i > p')    # => true
 
# now:
assert_select('div > i')  # => true
assert_select('div > p')  # => true
assert_select('i > p')    # => false
之前要比较含有 HTML entities 的元素要写未经转译的 HTML，现在写转译后的即可

# content: <p>AT&amp;T</p>
 
# before:
assert_select('p', 'AT&amp;T')  # => true
assert_select('p', 'AT&T')      # => false
 
# now:
assert_select('p', 'AT&T')      # => true
assert_select('p', 'AT&amp;T')  # => false
4 Railties
请参考 CHANGELOG 来了解更多细节。

4.1 移除
--skip-action-view 选项从 app generator 移除。 (Pull Request)

移除 rails application 命令。 (Pull Request)

4.2 弃用
生产环境新增 config.log_level 设置。 (Pull Request)

弃用 rake test:all，请改用 rake test 来执行 test 目录下的所有测试。 (Pull Request)

弃用 rake test:all:db，请改用 rake test:db。 (Pull Request)

弃用 Rails::Rack::LogTailer，没有替代方案。 (Commit)

4.3 值得一提的变化
web-console 导入为应用内建的 Gem。 (Pull Request)

Model 用来产生关联的 generator 添加 required 选项。 (Pull Request)

导入 after_bundle 回调到 Rails 模版。 (Pull Request)

导入 x 命名空间，可用来自订设置选项：

# config/environments/production.rb
config.x.payment_processing.schedule = :daily
config.x.payment_processing.retries  = 3
config.x.super_debugger              = true
这些选项都可以从设置对象里获取：

Rails.configuration.x.payment_processing.schedule # => :daily
Rails.configuration.x.payment_processing.retries  # => 3
Rails.configuration.x.super_debugger              # => true
(Commit)

导入 Rails::Application.config_for，用来给当前的环境载入设置

# config/exception_notification.yml:
production:
  url: http://127.0.0.1:8080
  namespace: my_app_production
development:
  url: http://localhost:3001
  namespace: my_app_development
 
# config/production.rb
Rails.application.configure do
  config.middleware.use ExceptionNotifier, config_for(:exception_notification)
end
(Pull Request)

产生器新增 --skip-turbolinks 选项，可在新建应用时拿掉 turbolink。 (Commit)

导入 bin/setup 脚本来启动（bootstrapping）应用。 (Pull Request)

config.assets.digest 在开发模式的缺省值改为 true。 (Pull Request)

导入给 rake notes 注册新扩充功能的 API。 (Pull Request)

导入 Rails.gem_version 作为返回 Gem::Version.new(Rails.version) 的便捷方法。 (Pull Request)

5 Action Pack
请参考 CHANGELOG 来了解更多细节。

5.1 移除
将 respond_with 以及类别层级的 respond_to 从 Rails 移除，移到 responders gem（版本 2.0）。要继续使用这个特性，请在 Gemfile 添加：gem 'responders', '~> 2.0'。(Pull Request)

移除弃用的 AbstractController::Helpers::ClassMethods::MissingHelperError， 改用 AbstractController::Helpers::MissingHelperError 取代。 (Commit)

5.2 弃用
弃用 *_path 帮助方法的 only_path 选项。 (Commit)

弃用 assert_tag、assert_no_tag、find_tag 以及 find_all_tag，请改用 assert_select。 (Commit)

弃用路由的 :to 选项里，:to 可以指向符号或不含井号的字串这两个功能。

get '/posts', to: MyRackApp    => (No change necessary)
get '/posts', to: 'post#index' => (No change necessary)
get '/posts', to: 'posts'      => get '/posts', controller: :posts
get '/posts', to: :index       => get '/posts', action: :index
(Commit)

弃用 URL 帮助方法不再支持使用字串作为键：

# bad
root_path('controller' => 'posts', 'action' => 'index')
 
# good
root_path(controller: 'posts', action: 'index')
(Pull Request)

5.3 值得一提的变化
*_filter 方法已经从文件中移除，已经不鼓励使用。偏好使用 *_action 方法：

after_filter          => after_action
append_after_filter   => append_after_action
append_around_filter  => append_around_action
append_before_filter  => append_before_action
around_filter         => around_action
before_filter         => before_action
prepend_after_filter  => prepend_after_action
prepend_around_filter => prepend_around_action
prepend_before_filter => prepend_before_action
skip_after_filter     => skip_after_action
skip_around_filter    => skip_around_action
skip_before_filter    => skip_before_action
skip_filter           => skip_action_callback
若应用程式依赖这些 *_filter 方法，应该使用 *_action 方法替换。 因为 *_filter 方法最终会从 Rails 里拿掉。 (Commit 1, 2)

render nothing: true 或算绘 nil 不再加入一个空白到响应主体。 (Pull Request)

Rails 现在会自动把模版的 digest 加入到 ETag。 (Pull Request)

传入 URL 辅助方法的片段现在会自动 Escaped。 (Commit)

导入 always_permitted_parameters 选项，用来设置全局允许赋值的参数。 缺省值是 ['controller', 'action']。 (Pull Request)

从 RFC 4791 新增 HTTP 方法 MKCALENDAR。 (Pull Request)

*_fragment.action_controller 通知消息的 Payload 现在会带有控制器和动作名称。 (Pull Request)

改善路由错误页面，搜索路由支持模糊搜寻。 (Pull Request)

新增关掉记录 CSRF 失败的选项。 (Pull Request)

当使用 Rails 服务器来提供静态资源时，若客户端支持 gzip，则会自动传送预先产生好的 gzip 静态资源。Asset Pipeline 缺省会给所有可压缩的静态资源产生 .gz 文件。传送 gzip 可将所需传输的数据量降到最小，并加速静态资源请求的存取。当然若要在 Rails 生产环境提供静态资源，最好还是使用 CDN。(Pull Request)

在整合测试里调用 process 帮助方法时，路径开始需要有 /。以前可以忽略开头的 /，但这是实作所产生的副产品，而不是有意新增的特性，譬如：

test "list all posts" do
  get "/posts"
  assert_response :success
end
6 Action View
请参考 CHANGELOG 来了解更多细节。

6.1 弃用
弃用 AbstractController::Base.parent_prefixes。想修改寻找视图的位置， 请覆盖 AbstractController::Base.local_prefixes。 (Pull Request)

弃用 ActionView::Digestor#digest(name, format, finder, options = {})，现在参数改用 Hash 传入。 (Pull Request)

6.2 值得一提的变化
render "foo/bar" 现在等同 render template: "foo/bar" 而不是 render file: "foo/bar"。(Pull Request)

隐藏栏位的表单辅助方法不再产生含有行内样式表的 <div> 元素。 (Pull Request)

导入一个特别的 #{partial_name}_iteration 局部变量，给在 collection 里渲染的部分视图（Partial）使用。这个变量可以通过 #index、#size、first? 以及 last? 等方法来获得目前迭代的状态。(Pull Request)

Placeholder I18n 遵循和 label I18n 一样的惯例。 (Pull Request)

7 Action Mailer
请参考 CHANGELOG 来了解更多细节。

7.1 弃用
Mailer 弃用所有 *_path 的帮助方法。请全面改用 *_url。 (Pull Request)

弃用 deliver 与 deliver!，请改用 deliver_now 或 deliver_now!。 (Pull Request)

7.2 值得一提的变化
link_to 和 url_for 在模版里缺省产生绝对路径，不再需要传入 only_path: false。 (Commit)

导入 deliver_later 方法，将邮件加到应用的队列里，用来异步发送邮件。 (Pull Request)

新增 show_previews 选项，用来在开发环境之外启用邮件预览特性。 (Pull Request)

8 Active Record
请参考 CHANGELOG 来了解更多细节。

8.1 移除
移除 cache_attributes 以及其它相关的方法，所有的属性现在都会缓存了。 (Pull Request)

移除已弃用的方法 ActiveRecord::Base.quoted_locking_column. (Pull Request)

移除已弃用的方法 ActiveRecord::Migrator.proper_table_name。 请改用 ActiveRecord::Migration 的实例方法：proper_table_name。 (Pull Request)

移除了未使用的 :timestamp 类型。把所有 timestamp 类型都改为 :datetime 的别名。 修正在 ActiveRecord 之外，栏位类型不一致的问题，譬如 XML 序列化。 (Pull Request)

8.2 弃用
弃用 after_commit 和 after_rollback 会吃掉错误的行为。 (Pull Request)

弃用对 has_many :through 自动侦测 counter cache 的支持。要自己对 has_many 和 belongs_to 关联，给 through 的记录手动设置。 (Pull Request)

弃用 .find 或 .exists? 可传入 Active Record 对象。请先对对象调用 #id。 (Commit 1, 2)

弃用仅支持一半的 PostgreSQL 范围数值（不包含起始值）。目前我们把 PostgreSQL 的范围对应到 Ruby 的范围。但由于 Ruby 的范围不支持不包含起始值，所以无法完全转换。

目前的解决方法是将起始数递增，这是不对的，已经弃用了。关于不知如何递增的子类型（比如没有定义 #succ）会对不包含起始值的抛出 ArgumentError。

(Commit)

弃用无连接调用 DatabaseTasks.load_schema。请改用 DatabaseTasks.load_schema_current 来取代。 (Commit)

弃用 sanitize_sql_hash_for_conditions，没有替代方案。使用 Relation 来进行查询或更新是推荐的做法。 (Commit)

弃用 add_timestamps 和 t.timestamps 可不用传入 :null 选项的行为。Rails 5 将把缺省 null: true 改为 null: false。 (Pull Request)

弃用 Reflection#source_macro，没有替代方案。Active Record 不再需要这个方法了。 (Pull Request)

弃用 serialized_attributes，没有替代方案。 (Pull Request)

弃用了当栏位不存在时，还会从 column_for_attribute 返回 nil 的情况。 Rails 5.0 将会返回 Null Object。 (Pull Request)

弃用了 serialized_attributes，没有替代方案。 (Pull Request)

弃用依赖实例状态（有定义接受参数的作用域）的关联可以使用 .joins、.preload 以及 .eager_load 的行为 (Commit)

8.3 值得一提的变化
SchemaDumper 对 create_table 使用 force: :cascade。这样就可以重载加入外键的纲要文件。

单数关联增加 :required 选项，用来定义关联的存在性验证。 (Pull Request)

ActiveRecord::Dirty 现在会侦测可变数值的变化。序列化过的属性只在有变更时才会保存。 修复了像是 PostgreSQL 不会侦测到字串或 JSON 栏位改变的问题。 (Pull Requests 1, 2, 3)

导入 bin/rake db:purge 任务，用来清空当前环境的数据库。 (Commit)

导入 ActiveRecord::Base#validate!，若记录不合法时会抛出 RecordInvalid。 (Pull Request)

引入 #validate 作为 #valid? 的别名。 (Pull Request)

#touch 现在可一次对多属性操作。 (Pull Request)

PostgreSQL 适配器现在支持 PostgreSQL 9.4+ 的 jsonb 数据类型。 (Pull Request)

新增 PostgreSQL 适配器的 citext 支持。 (Pull Request)

PostgreSQL 与 SQLite 适配器不再默认限制字串只能 255 字符。 (Pull Request)

新增 PostgreSQL 适配器的使用自建的范围类型支持。 (Commit)

sqlite3:///some/path 现在可以解析系统的绝对路径 /some/path。 相对路径请使用 sqlite3:some/path。(先前是 sqlite3:///some/path 会解析成 some/path。这个行为已在 Rails 4.1 被弃用了。 Rails 4.1.) (Pull Request)

新增 MySQL 5.6 以上版本的 fractional seconds 支持。 (Pull Request 1, 2)

新增 ActiveRecord::Base 对象的 #pretty_print 方法。 (Pull Request)

ActiveRecord::Base#reload 现在的行为同 m = Model.find(m.id)，代表不再给自定的 select 保存额外的属性。 (Pull Request)

ActiveRecord::Base#reflections 现在返回的 hash 的键是字串类型，而不是符号。 (Pull Request)

迁移的 references 方法支持 type 选项，用来指定外键的类型，比如 :uuid。 (Pull Request)

9 Active Model
请参考 CHANGELOG 来了解更多细节。

9.1 移除
移除了 Validator#setup，没有替代方案。 (Pull Request)
9.2 弃用
弃用 reset_#{attribute}，请改用 restore_#{attribute}。 (Pull Request)

弃用 ActiveModel::Dirty#reset_changes，请改用 #clear_changes_information。 (Pull Request)

9.3 值得一提的变化
引入 #validate 作为 #valid? 的别名。 (Pull Request)

ActiveModel::Dirty 导入 restore_attributes 方法，用来回复已修改的属性到先前的数值。 (Pull Request 1, 2)

has_secure_password 现在缺省允许空密码（只含空白的密码也算空密码）。 (Pull Request)

验证启用时，has_secure_password 现在会检查密码是否少于 72 个字符。 (Pull Request)

10 Active Support
请参考 CHANGELOG 来了解更多细节。

10.1 移除
移除弃用的 Numeric#ago、Numeric#until、Numeric#since 以及 Numeric#from_now. (Commit)

移除弃用 ActiveSupport::Callbacks 基于字串的终止符。 (Pull Request)

10.2 弃用
弃用 Kernel#silence_stderr、Kernel#capture 以及 Kernel#quietly 方法，没有替代方案。(Pull Request)

弃用 Class#superclass_delegating_accessor，请改用 Class#class_attribute。 (Pull Request)

弃用 ActiveSupport::SafeBuffer#prepend! 请改用 ActiveSupport::SafeBuffer#prepend（两者功能相同）。 (Pull Request)

10.3 值得一提的变化
导入新的设置选项： active_support.test_order，用来指定测试执行的顺序，预设是 :sorted，在 Rails 5.0 将会改成 :random。(Commit)

Object#try 和 Object#try! 方法现在不需要消息接收者也可以使用。 (Commit, Pull Request)

travel_to 测试辅助方法现在会把 usec 部分截断为 0。 (Commit)

导入 Object#itself 作为 identity 函数（返回自身的函数）。(Commit 1 和 2)

Object#with_options 方法现在不需要消息接收者也可以使用。 (Pull Request)

导入 String#truncate_words 方法，可指定要单词截断至几个单词。 (Pull Request)

新增 Hash#transform_values 与 Hash#transform_values! 方法，来简化 Hash 值需要更新、但键保留不变这样的常见模式。 (Pull Request)

humanize 现在会去掉前面的底线。 (Commit)

导入 Concern#class_methods 来取代 module ClassMethods 以及 Kernel#concern，来避免使用 module Foo; extend ActiveSupport::Concern; end 这样的样板。 (Commit)

新增一篇指南，关于常量的载入与重载。

-------------
  group出时间日期统计
@clicks = Click.select("count(*) as c, date_part('year', created_at) as y, date_part('month', created_at) as m").group("y", "m").where({:user_id => current_user.id})
This will give you a hash in the format [year, month] => count. 

---------------
使用 logrotate 来管理日志文件

28 June 2012

logrotate 是 Linux 下的一个日志管理工具。通过 logrotate 可以很轻松地管理（拆分、压缩等）系统的所有日志文件。 通过配置，我们可以按日志大小或者固定周期来管理日志文件。

安装 logrotate

sudo apt-get install logrotate
打开配置文件

sudo vim /etc/logrotate.conf
在文件最后增加以下配置

/PATH/TO/YOUR/LOG/*.log {
    daily          # 按日，也可以 weekly 按周，monthly 按月
    dateext        # 增加日期作为后缀
    missingok      # 如果文件不存在，忽略错误信息
    rotate 30      # 保留 30 份
    compress       # 压缩
    delaycompress  # 延迟压缩，也就是本次拆分的文件在下次执行时再压缩
    notifempty     # 忽略空白文件
    copytruncate   # 拆分文件后，清空原有文件，而不是创建一个新文件
    size 100M
}
马上执行 logrotate

sudo /usr/sbin/logrotate -f /etc/logrotate.conf
查看你的 log 文件所在目录，应该可以得到类似这个的结果

-rw-r--r-- 1 deploy deploy  0K 2012-06-27 23:39 production.log
-rw-r--r-- 1 deploy deploy  27M 2012-06-27 23:15 production.log-20120627

-------------
Rails5.0新特性


再也不需要用 Grape 来写 API 了！轻量级的 Controller，为富客户端而设计！

你甚至可以直接 rails new backend --api 创建 API only 的 Rails Application！当然依然还有许多有待完善的地方，这是一个新的起点。默认 API mode 只是尝试调用 Model 的 "#to_json" 方法来输出结果。但你可以选择用 Jbuilder, Active Model Serializers, 或者尝试新出的 JSONAPI::Resources 等来实现一些高级特性。

命令行里，以后 rails 一个命令包涵了 rake, rails 里面的所有内容，所以现在 bin/rails db:migrate 代替了 bin/rake db:migrate；
New Attributes API - 在某些时候如果你需要的话，你可以在 Model 里面定义用 attribute 定义一个新的类型，它会覆盖原有的字段；
"https://github.com/rails/rails/blob/8c752c7ac739d5a86d4136ab1e9d0142c4041e58/activerecord/lib/active_record/attributes.rb"
现在跑测试的时候如果有错误会直接输出，无需等待跑完整个用例；
Model 现在开始继承于 ApplicationRecord ，在 app/models 里面的一个新文件；
ActiveRecord::Relation#in_batches 更低的内存消耗；
Active Record 新的 or 查询方式：Post.where(‘id = 1’).or(Post.where(‘id = 2’)) ；
Active Record callbacks 要中断执行，现在需要用 throw(:abort) 的方式，而不是像以前返回 false。
同时也带来了 Turbolinks 5

#!!!!Rails5 model association belongs_to required默认为true
在initializers/net_framework_defaults.rb下可以修改这个，把他改为false
Rails.application.config.active_record.belongs_to_required_by_default = false

-------------
mongoid取代active record 
Getting Rid of Active Record

Now that you have a mongoid.yml you can't wait to delete that pesky database.yml, right? Do it and you'll start getting ActiveRecord errors all over the place. You don't need ActiveRecord unless you're trying to use Mongo in concert with a SQL database. Here's how you remove ActiveRecord from the most recent version of Rails.

Open myapp/config/application.rb and near the top, remove the line require "rails/all" and add the following lines so you end up with this:

require "action_controller/railtie"
require "action_mailer/railtie"
require "active_resource/railtie" # Comment this line for Rails 4.0+
require "rails/test_unit/railtie"
# require "sprockets/railtie" # Uncomment this line for Rails 3.1+
For Rails 3.2+ you'll also need to remove configuration options for Active Record that reside in your environments, ie myapp/config/environments/development.rb. Make sure any references to active_record are commented out like as follows

# Rails 3.2+, < 4.0
# config.active_record.mass_assignment_sanitizer = :strict
# config.active_record.auto_explain_threshold_in_seconds = 0.5
#
# Rails 4.0+
# config.active_record.migration_error = :page_load
For Rails 3.2.3+ but < 4.0 you'll also need to comment out the following line in myapp/config/application.rb.

# config.active_record.whitelist_attributes = true
You can also generate your new rails app sans Active Record like so.

rails new app_name --skip-active-record
Sinatra, Padrino, and others

You can create your mongoid.yml and place it anywhere you like. Just be sure that on application initialization you do the following:

Mongoid.load!("path/to/your/mongoid.yml") '


---------------------
默认api action都用json格式的 hack
官方例子 resource :people, defaults: {format: :json} 不靠谱, 用这个

You can add a before_filter in your controller to set the request format to json:

# app/controllers/foos_controller.rb
#
 before_action :set_default_response_format
#
 protected

def set_default_response_format
 request.format = :json
end
#   This will set all response format to json. If you want to allow other formats, you could check for the presence of format parameter when setting request.format, for e.g:
#
def set_default_response_format
 request.format = :json unless params[:format]
end

-----------------------
修改 resource 下member等里默认的/:id param name 

例如: 需要 show /users/:out_id/fuck
Rails5 可以
resouces :users, param: :out_id do
  member do
    get :fuck
  end
end

Rails 3
resources :events do
  member do
    get 'register/:participant_type_id', :action => 'register'
  end
end
end

----------------------
before_filter 或 before_action里传参数的写法
before_filter(only: [:index, :show]) { check_login(params[:user_out_id])  } #这样就可以定义不一样的验证参数

---------------------
PG postgresql 的各种问题

用PostgresApp安装postgresql时，遭遇bundle 不能通过pg gem, 找不到pg_conf的话

find /Application/ -name pg_conf, 可以找到以下项目

/Applications/Postgres.app/Contents/Versions/9.6/bin/pg_config

然后 bundle config build.pg --with-pg-config=/Applications/Postgres.app/Contents/Versions/9.6/bin/pg_config

#rails db:create 说权限不足时
ALTER USER scott CREATEDB; #相当于给用户赋值创建db权限

#已存在db时
GRANT ALL PRIVILEGES ON  DATABASE database_name to new_user;
ALTER DATABASE database_name owner to new_user;

\q退出命令台

生产环境里的pg postgres安装
sudo apt-get install postgresql-client
服务器安装
sudo apt-get install postgresql postgresql-contrib
获取Installing PostGIS, procedural languages, client interfaces等插件列表
apt-cache search postgres
Ruby PG gem安装，需要生成Native Extension
首先安装相应package
sudo apt-get install libpq-dev
找到pg_config所在位置
sudo find / -name pg_config
安装pg gem
gem install pg -- --with-pg-config=/usr/bin/pg_config
到这里位置，数据库就安装完成了




--------------------
console清理session
rake db:sessions:clear


-------------------
写rails tasks or rake tasks 传参数的方法，还有zsh里遇到传参数不行的问题解决办法
namespace :tweets do
  desc 'Send some tweets to a user'
  task :send, [:username] => [:environment] do |t, args|
    Tweet.send(args[:username])
  end
end

这样在console 跑 rake tweets:send[jas] 就可以把 "jas"传到程序里，

但是在zsh会遇到no matches found的问题,用单引号去跑就好

rake 'tweets:send[jas]'

----------------
factory_girl 从已存在的model中再生成

rails g factory_girl:model Car name speed:integer
还可以删除

rails d factory_girl:model Car name speed:integer

--------
model before_update 只检测某个attribute 变化
before_update :check_share_cut, if: :share_cut_changed?


----------------
Rails5 skip_before_action 会出现非常蛋疼的问题，有时明明继承父类已经有了这个方法，但是在子类Controller里skip这个before_action, 居然会报 method undefined, 加上raise: false的参数，不让error冒泡出来，到读取到父类方法即可  

ok, this is because now, in Rails 5,
ActiveSupport::Callbacks#skip_callback now raises an ArgumentError if an unrecognized callback is removed. (https://github.com/rails/rails/blob/v5.0.0.beta1/activesupport/CHANGELOG.md)

You can see the diff for skip_callback here:
  Rails 4 will ignore the unrecognized callback
https://github.com/rails/rails/blob/489a8f2a44dc9cea09154ee1ee2557d1f037c7d4/activesupport/lib/active_support/callbacks.rb#L626

Rails 5 will raise the exception https://github.com/rails/rails/blob/6dfab475ca230dfcad7a603483431c8e7a8f908e/activesupport/lib/active_support/callbacks.rb#L634

A solution is then to add the option raise: false, to the skip_before_action :set_user_by_token

I know this is not a pretty solution, but it replicate Rails 4 behavior.

class Operation::SessionsController < Operation::ApplicationController
 skip_before_action :check_merchant_login, only: [:new, :create], raise: false









------------
使用ActiveSupport::Rescuble更好的处理controller里的exception

class Queue::Jobs::Base
  include ActiveSupport::Rescuable

  rescue_from ActiveRecord::RecordNotFound, :with => :known_error

  protected

    def execute(&block)
      yield
    rescue Exception => exception
      rescue_with_handler(exception) || raise
    end

    def known_error(exception)
      @error = exception
      Rails.logger.error "[JOBS] Exception #{exception.class}: #{exception.message}"
    end

end

class Queue::Jobs::FetchWhois < Queue::Jobs::Base

  rescue_from Hostname::NotLikeDomain, :with => :known_error
  # ActiveRecord::RecordNotFound already defined in parent class

  def initialize(hostname_id)
    @hostname_id = hostname_id
  end

  def perform
    execute do
      hostname = Hostname.find(@hostname_id)
    end
  end

end
